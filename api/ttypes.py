#
# Autogenerated by Thrift Compiler (0.9.3)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol

try:
    from thrift.protocol import fastbinary
except:
    fastbinary = None


class CommitItemChangeType:
    ADDED = 0
    DELETED = 1
    REPLACED = 2
    UNKNOWN = 3
    UPDATED = 4

    _VALUES_TO_NAMES = {
        0: "ADDED",
        1: "DELETED",
        2: "REPLACED",
        3: "UNKNOWN",
        4: "UPDATED",
    }

    _NAMES_TO_VALUES = {
        "ADDED": 0,
        "DELETED": 1,
        "REPLACED": 2,
        "UNKNOWN": 3,
        "UPDATED": 4,
    }


class HawkPluginCategory:
    BACKEND = 0
    GRAPH_CHANGE_LISTENER = 1
    INDEX_FACTORY = 2
    METAMODEL_INTROSPECTOR = 3
    METAMODEL_RESOURCE_FACTORY = 4
    METAMODEL_UPDATER = 5
    MODEL_RESOURCE_FACTORY = 6
    MODEL_UPDATER = 7
    QUERY_ENGINE = 8
    VCS_MANAGER = 9

    _VALUES_TO_NAMES = {
        0: "BACKEND",
        1: "GRAPH_CHANGE_LISTENER",
        2: "INDEX_FACTORY",
        3: "METAMODEL_INTROSPECTOR",
        4: "METAMODEL_RESOURCE_FACTORY",
        5: "METAMODEL_UPDATER",
        6: "MODEL_RESOURCE_FACTORY",
        7: "MODEL_UPDATER",
        8: "QUERY_ENGINE",
        9: "VCS_MANAGER",
    }

    _NAMES_TO_VALUES = {
        "BACKEND": 0,
        "GRAPH_CHANGE_LISTENER": 1,
        "INDEX_FACTORY": 2,
        "METAMODEL_INTROSPECTOR": 3,
        "METAMODEL_RESOURCE_FACTORY": 4,
        "METAMODEL_UPDATER": 5,
        "MODEL_RESOURCE_FACTORY": 6,
        "MODEL_UPDATER": 7,
        "QUERY_ENGINE": 8,
        "VCS_MANAGER": 9,
    }


class HawkState:
    RUNNING = 0
    STOPPED = 1
    UPDATING = 2

    _VALUES_TO_NAMES = {
        0: "RUNNING",
        1: "STOPPED",
        2: "UPDATING",
    }

    _NAMES_TO_VALUES = {
        "RUNNING": 0,
        "STOPPED": 1,
        "UPDATING": 2,
    }


class SubscriptionDurability:
    DEFAULT = 0
    DURABLE = 1
    TEMPORARY = 2

    _VALUES_TO_NAMES = {
        0: "DEFAULT",
        1: "DURABLE",
        2: "TEMPORARY",
    }

    _NAMES_TO_VALUES = {
        "DEFAULT": 0,
        "DURABLE": 1,
        "TEMPORARY": 2,
    }


class CommitItem:
    """
  Attributes:
   - repoURL
   - revision
   - path
   - type
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "repoURL", None, None,),  # 1
        (2, TType.STRING, "revision", None, None,),  # 2
        (3, TType.STRING, "path", None, None,),  # 3
        (4, TType.I32, "type", None, None,),  # 4
    )

    def __init__(
        self, repoURL=None, revision=None, path=None, type=None,
    ):
        self.repoURL = repoURL
        self.revision = revision
        self.path = path
        self.type = type

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.repoURL = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.revision = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.path = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("CommitItem")
        if self.repoURL is not None:
            oprot.writeFieldBegin("repoURL", TType.STRING, 1)
            oprot.writeString(self.repoURL)
            oprot.writeFieldEnd()
        if self.revision is not None:
            oprot.writeFieldBegin("revision", TType.STRING, 2)
            oprot.writeString(self.revision)
            oprot.writeFieldEnd()
        if self.path is not None:
            oprot.writeFieldBegin("path", TType.STRING, 3)
            oprot.writeString(self.path)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin("type", TType.I32, 4)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.repoURL is None:
            raise TProtocol.TProtocolException(
                message="Required field repoURL is unset!"
            )
        if self.revision is None:
            raise TProtocol.TProtocolException(
                message="Required field revision is unset!"
            )
        if self.path is None:
            raise TProtocol.TProtocolException(message="Required field path is unset!")
        if self.type is None:
            raise TProtocol.TProtocolException(message="Required field type is unset!")
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.repoURL)
        value = (value * 31) ^ hash(self.revision)
        value = (value * 31) ^ hash(self.path)
        value = (value * 31) ^ hash(self.type)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Credentials:
    """
  Attributes:
   - username
   - password
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "username", None, None,),  # 1
        (2, TType.STRING, "password", None, None,),  # 2
    )

    def __init__(
        self, username=None, password=None,
    ):
        self.username = username
        self.password = password

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.username = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.password = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("Credentials")
        if self.username is not None:
            oprot.writeFieldBegin("username", TType.STRING, 1)
            oprot.writeString(self.username)
            oprot.writeFieldEnd()
        if self.password is not None:
            oprot.writeFieldBegin("password", TType.STRING, 2)
            oprot.writeString(self.password)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.username is None:
            raise TProtocol.TProtocolException(
                message="Required field username is unset!"
            )
        if self.password is None:
            raise TProtocol.TProtocolException(
                message="Required field password is unset!"
            )
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.username)
        value = (value * 31) ^ hash(self.password)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DerivedAttributeSpec:
    """
  Attributes:
   - metamodelUri
   - typeName
   - attributeName
   - attributeType
   - isMany
   - isOrdered
   - isUnique
   - derivationLanguage
   - derivationLogic
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "metamodelUri", None, None,),  # 1
        (2, TType.STRING, "typeName", None, None,),  # 2
        (3, TType.STRING, "attributeName", None, None,),  # 3
        (4, TType.STRING, "attributeType", None, None,),  # 4
        (5, TType.BOOL, "isMany", None, None,),  # 5
        (6, TType.BOOL, "isOrdered", None, None,),  # 6
        (7, TType.BOOL, "isUnique", None, None,),  # 7
        (8, TType.STRING, "derivationLanguage", None, None,),  # 8
        (9, TType.STRING, "derivationLogic", None, None,),  # 9
    )

    def __init__(
        self,
        metamodelUri=None,
        typeName=None,
        attributeName=None,
        attributeType=None,
        isMany=None,
        isOrdered=None,
        isUnique=None,
        derivationLanguage=None,
        derivationLogic=None,
    ):
        self.metamodelUri = metamodelUri
        self.typeName = typeName
        self.attributeName = attributeName
        self.attributeType = attributeType
        self.isMany = isMany
        self.isOrdered = isOrdered
        self.isUnique = isUnique
        self.derivationLanguage = derivationLanguage
        self.derivationLogic = derivationLogic

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.metamodelUri = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.typeName = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.attributeName = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.attributeType = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.isMany = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.isOrdered = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.isUnique = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.derivationLanguage = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.derivationLogic = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("DerivedAttributeSpec")
        if self.metamodelUri is not None:
            oprot.writeFieldBegin("metamodelUri", TType.STRING, 1)
            oprot.writeString(self.metamodelUri)
            oprot.writeFieldEnd()
        if self.typeName is not None:
            oprot.writeFieldBegin("typeName", TType.STRING, 2)
            oprot.writeString(self.typeName)
            oprot.writeFieldEnd()
        if self.attributeName is not None:
            oprot.writeFieldBegin("attributeName", TType.STRING, 3)
            oprot.writeString(self.attributeName)
            oprot.writeFieldEnd()
        if self.attributeType is not None:
            oprot.writeFieldBegin("attributeType", TType.STRING, 4)
            oprot.writeString(self.attributeType)
            oprot.writeFieldEnd()
        if self.isMany is not None:
            oprot.writeFieldBegin("isMany", TType.BOOL, 5)
            oprot.writeBool(self.isMany)
            oprot.writeFieldEnd()
        if self.isOrdered is not None:
            oprot.writeFieldBegin("isOrdered", TType.BOOL, 6)
            oprot.writeBool(self.isOrdered)
            oprot.writeFieldEnd()
        if self.isUnique is not None:
            oprot.writeFieldBegin("isUnique", TType.BOOL, 7)
            oprot.writeBool(self.isUnique)
            oprot.writeFieldEnd()
        if self.derivationLanguage is not None:
            oprot.writeFieldBegin("derivationLanguage", TType.STRING, 8)
            oprot.writeString(self.derivationLanguage)
            oprot.writeFieldEnd()
        if self.derivationLogic is not None:
            oprot.writeFieldBegin("derivationLogic", TType.STRING, 9)
            oprot.writeString(self.derivationLogic)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.metamodelUri is None:
            raise TProtocol.TProtocolException(
                message="Required field metamodelUri is unset!"
            )
        if self.typeName is None:
            raise TProtocol.TProtocolException(
                message="Required field typeName is unset!"
            )
        if self.attributeName is None:
            raise TProtocol.TProtocolException(
                message="Required field attributeName is unset!"
            )
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.metamodelUri)
        value = (value * 31) ^ hash(self.typeName)
        value = (value * 31) ^ hash(self.attributeName)
        value = (value * 31) ^ hash(self.attributeType)
        value = (value * 31) ^ hash(self.isMany)
        value = (value * 31) ^ hash(self.isOrdered)
        value = (value * 31) ^ hash(self.isUnique)
        value = (value * 31) ^ hash(self.derivationLanguage)
        value = (value * 31) ^ hash(self.derivationLogic)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class FailedQuery(TException):
    """
  Attributes:
   - reason
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "reason", None, None,),  # 1
    )

    def __init__(
        self, reason=None,
    ):
        self.reason = reason

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.reason = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("FailedQuery")
        if self.reason is not None:
            oprot.writeFieldBegin("reason", TType.STRING, 1)
            oprot.writeString(self.reason)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.reason is None:
            raise TProtocol.TProtocolException(
                message="Required field reason is unset!"
            )
        return

    def __str__(self):
        return repr(self)

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.reason)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class File:
    """
  Attributes:
   - name
   - contents
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "name", None, None,),  # 1
        (2, TType.STRING, "contents", None, None,),  # 2
    )

    def __init__(
        self, name=None, contents=None,
    ):
        self.name = name
        self.contents = contents

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.contents = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("File")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        if self.contents is not None:
            oprot.writeFieldBegin("contents", TType.STRING, 2)
            oprot.writeString(self.contents)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocol.TProtocolException(message="Required field name is unset!")
        if self.contents is None:
            raise TProtocol.TProtocolException(
                message="Required field contents is unset!"
            )
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.name)
        value = (value * 31) ^ hash(self.contents)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class HawkFactoryNotFound(TException):
    """
  Attributes:
   - factoryName
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "factoryName", None, None,),  # 1
    )

    def __init__(
        self, factoryName=None,
    ):
        self.factoryName = factoryName

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.factoryName = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("HawkFactoryNotFound")
        if self.factoryName is not None:
            oprot.writeFieldBegin("factoryName", TType.STRING, 1)
            oprot.writeString(self.factoryName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.factoryName)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class HawkInstance:
    """
  Attributes:
   - name
   - state
   - message
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "name", None, None,),  # 1
        (2, TType.I32, "state", None, None,),  # 2
        (3, TType.STRING, "message", None, None,),  # 3
    )

    def __init__(
        self, name=None, state=None, message=None,
    ):
        self.name = name
        self.state = state
        self.message = message

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.state = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.message = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("HawkInstance")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        if self.state is not None:
            oprot.writeFieldBegin("state", TType.I32, 2)
            oprot.writeI32(self.state)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin("message", TType.STRING, 3)
            oprot.writeString(self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocol.TProtocolException(message="Required field name is unset!")
        if self.state is None:
            raise TProtocol.TProtocolException(message="Required field state is unset!")
        if self.message is None:
            raise TProtocol.TProtocolException(
                message="Required field message is unset!"
            )
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.name)
        value = (value * 31) ^ hash(self.state)
        value = (value * 31) ^ hash(self.message)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class HawkInstanceNotFound(TException):
    """
  Attributes:
   - instanceName
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "instanceName", None, None,),  # 1
    )

    def __init__(
        self, instanceName=None,
    ):
        self.instanceName = instanceName

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.instanceName = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("HawkInstanceNotFound")
        if self.instanceName is not None:
            oprot.writeFieldBegin("instanceName", TType.STRING, 1)
            oprot.writeString(self.instanceName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.instanceName)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class HawkInstanceNotRunning(TException):
    """
  Attributes:
   - instanceName
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "instanceName", None, None,),  # 1
    )

    def __init__(
        self, instanceName=None,
    ):
        self.instanceName = instanceName

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.instanceName = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("HawkInstanceNotRunning")
        if self.instanceName is not None:
            oprot.writeFieldBegin("instanceName", TType.STRING, 1)
            oprot.writeString(self.instanceName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.instanceName)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class HawkMetamodelNotFound(TException):
    """
  Attributes:
   - metamodelURI
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "metamodelURI", None, None,),  # 1
    )

    def __init__(
        self, metamodelURI=None,
    ):
        self.metamodelURI = metamodelURI

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.metamodelURI = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("HawkMetamodelNotFound")
        if self.metamodelURI is not None:
            oprot.writeFieldBegin("metamodelURI", TType.STRING, 1)
            oprot.writeString(self.metamodelURI)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.metamodelURI)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class HawkPlugin:
    """
  Attributes:
   - name
   - description
   - category
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "name", None, None,),  # 1
        (2, TType.STRING, "description", None, None,),  # 2
        (3, TType.I32, "category", None, None,),  # 3
    )

    def __init__(
        self, name=None, description=None, category=None,
    ):
        self.name = name
        self.description = description
        self.category = category

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.description = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.category = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("HawkPlugin")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        if self.description is not None:
            oprot.writeFieldBegin("description", TType.STRING, 2)
            oprot.writeString(self.description)
            oprot.writeFieldEnd()
        if self.category is not None:
            oprot.writeFieldBegin("category", TType.I32, 3)
            oprot.writeI32(self.category)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocol.TProtocolException(message="Required field name is unset!")
        if self.description is None:
            raise TProtocol.TProtocolException(
                message="Required field description is unset!"
            )
        if self.category is None:
            raise TProtocol.TProtocolException(
                message="Required field category is unset!"
            )
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.name)
        value = (value * 31) ^ hash(self.description)
        value = (value * 31) ^ hash(self.category)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class HawkStateEvent:
    """
  Attributes:
   - timestamp
   - state
   - message
  """

    thrift_spec = (
        None,  # 0
        (1, TType.I64, "timestamp", None, None,),  # 1
        (2, TType.I32, "state", None, None,),  # 2
        (3, TType.STRING, "message", None, None,),  # 3
    )

    def __init__(
        self, timestamp=None, state=None, message=None,
    ):
        self.timestamp = timestamp
        self.state = state
        self.message = message

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.state = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.message = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("HawkStateEvent")
        if self.timestamp is not None:
            oprot.writeFieldBegin("timestamp", TType.I64, 1)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.state is not None:
            oprot.writeFieldBegin("state", TType.I32, 2)
            oprot.writeI32(self.state)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin("message", TType.STRING, 3)
            oprot.writeString(self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.timestamp is None:
            raise TProtocol.TProtocolException(
                message="Required field timestamp is unset!"
            )
        if self.state is None:
            raise TProtocol.TProtocolException(message="Required field state is unset!")
        if self.message is None:
            raise TProtocol.TProtocolException(
                message="Required field message is unset!"
            )
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.timestamp)
        value = (value * 31) ^ hash(self.state)
        value = (value * 31) ^ hash(self.message)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class HawkSynchronizationEndEvent:
    """
  Attributes:
   - timestampNanos
  """

    thrift_spec = (
        None,  # 0
        (1, TType.I64, "timestampNanos", None, None,),  # 1
    )

    def __init__(
        self, timestampNanos=None,
    ):
        self.timestampNanos = timestampNanos

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.timestampNanos = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("HawkSynchronizationEndEvent")
        if self.timestampNanos is not None:
            oprot.writeFieldBegin("timestampNanos", TType.I64, 1)
            oprot.writeI64(self.timestampNanos)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.timestampNanos is None:
            raise TProtocol.TProtocolException(
                message="Required field timestampNanos is unset!"
            )
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.timestampNanos)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class HawkSynchronizationStartEvent:
    """
  Attributes:
   - timestampNanos
  """

    thrift_spec = (
        None,  # 0
        (1, TType.I64, "timestampNanos", None, None,),  # 1
    )

    def __init__(
        self, timestampNanos=None,
    ):
        self.timestampNanos = timestampNanos

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.timestampNanos = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("HawkSynchronizationStartEvent")
        if self.timestampNanos is not None:
            oprot.writeFieldBegin("timestampNanos", TType.I64, 1)
            oprot.writeI64(self.timestampNanos)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.timestampNanos is None:
            raise TProtocol.TProtocolException(
                message="Required field timestampNanos is unset!"
            )
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.timestampNanos)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class HawkTypeNotFound(TException):
    """
  Attributes:
   - typeName
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "typeName", None, None,),  # 1
    )

    def __init__(
        self, typeName=None,
    ):
        self.typeName = typeName

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.typeName = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("HawkTypeNotFound")
        if self.typeName is not None:
            oprot.writeFieldBegin("typeName", TType.STRING, 1)
            oprot.writeString(self.typeName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.typeName)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class IndexedAttributeSpec:
    """
  Attributes:
   - metamodelUri
   - typeName
   - attributeName
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "metamodelUri", None, None,),  # 1
        (2, TType.STRING, "typeName", None, None,),  # 2
        (3, TType.STRING, "attributeName", None, None,),  # 3
    )

    def __init__(
        self, metamodelUri=None, typeName=None, attributeName=None,
    ):
        self.metamodelUri = metamodelUri
        self.typeName = typeName
        self.attributeName = attributeName

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.metamodelUri = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.typeName = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.attributeName = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("IndexedAttributeSpec")
        if self.metamodelUri is not None:
            oprot.writeFieldBegin("metamodelUri", TType.STRING, 1)
            oprot.writeString(self.metamodelUri)
            oprot.writeFieldEnd()
        if self.typeName is not None:
            oprot.writeFieldBegin("typeName", TType.STRING, 2)
            oprot.writeString(self.typeName)
            oprot.writeFieldEnd()
        if self.attributeName is not None:
            oprot.writeFieldBegin("attributeName", TType.STRING, 3)
            oprot.writeString(self.attributeName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.metamodelUri is None:
            raise TProtocol.TProtocolException(
                message="Required field metamodelUri is unset!"
            )
        if self.typeName is None:
            raise TProtocol.TProtocolException(
                message="Required field typeName is unset!"
            )
        if self.attributeName is None:
            raise TProtocol.TProtocolException(
                message="Required field attributeName is unset!"
            )
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.metamodelUri)
        value = (value * 31) ^ hash(self.typeName)
        value = (value * 31) ^ hash(self.attributeName)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InvalidDerivedAttributeSpec(TException):
    """
  Attributes:
   - reason
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "reason", None, None,),  # 1
    )

    def __init__(
        self, reason=None,
    ):
        self.reason = reason

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.reason = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("InvalidDerivedAttributeSpec")
        if self.reason is not None:
            oprot.writeFieldBegin("reason", TType.STRING, 1)
            oprot.writeString(self.reason)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.reason is None:
            raise TProtocol.TProtocolException(
                message="Required field reason is unset!"
            )
        return

    def __str__(self):
        return repr(self)

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.reason)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InvalidIndexedAttributeSpec(TException):
    """
  Attributes:
   - reason
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "reason", None, None,),  # 1
    )

    def __init__(
        self, reason=None,
    ):
        self.reason = reason

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.reason = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("InvalidIndexedAttributeSpec")
        if self.reason is not None:
            oprot.writeFieldBegin("reason", TType.STRING, 1)
            oprot.writeString(self.reason)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.reason is None:
            raise TProtocol.TProtocolException(
                message="Required field reason is unset!"
            )
        return

    def __str__(self):
        return repr(self)

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.reason)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InvalidMetamodel(TException):
    """
  Attributes:
   - reason
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "reason", None, None,),  # 1
    )

    def __init__(
        self, reason=None,
    ):
        self.reason = reason

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.reason = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("InvalidMetamodel")
        if self.reason is not None:
            oprot.writeFieldBegin("reason", TType.STRING, 1)
            oprot.writeString(self.reason)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.reason is None:
            raise TProtocol.TProtocolException(
                message="Required field reason is unset!"
            )
        return

    def __str__(self):
        return repr(self)

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.reason)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InvalidPollingConfiguration(TException):
    """
  Attributes:
   - reason
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "reason", None, None,),  # 1
    )

    def __init__(
        self, reason=None,
    ):
        self.reason = reason

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.reason = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("InvalidPollingConfiguration")
        if self.reason is not None:
            oprot.writeFieldBegin("reason", TType.STRING, 1)
            oprot.writeString(self.reason)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.reason is None:
            raise TProtocol.TProtocolException(
                message="Required field reason is unset!"
            )
        return

    def __str__(self):
        return repr(self)

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.reason)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InvalidQuery(TException):
    """
  Attributes:
   - reason
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "reason", None, None,),  # 1
    )

    def __init__(
        self, reason=None,
    ):
        self.reason = reason

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.reason = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("InvalidQuery")
        if self.reason is not None:
            oprot.writeFieldBegin("reason", TType.STRING, 1)
            oprot.writeString(self.reason)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.reason is None:
            raise TProtocol.TProtocolException(
                message="Required field reason is unset!"
            )
        return

    def __str__(self):
        return repr(self)

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.reason)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InvalidTransformation:
    """
  Attributes:
   - reason
   - location
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "reason", None, None,),  # 1
        (2, TType.STRING, "location", None, None,),  # 2
    )

    def __init__(
        self, reason=None, location=None,
    ):
        self.reason = reason
        self.location = location

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.reason = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.location = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("InvalidTransformation")
        if self.reason is not None:
            oprot.writeFieldBegin("reason", TType.STRING, 1)
            oprot.writeString(self.reason)
            oprot.writeFieldEnd()
        if self.location is not None:
            oprot.writeFieldBegin("location", TType.STRING, 2)
            oprot.writeString(self.location)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.reason is None:
            raise TProtocol.TProtocolException(
                message="Required field reason is unset!"
            )
        if self.location is None:
            raise TProtocol.TProtocolException(
                message="Required field location is unset!"
            )
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.reason)
        value = (value * 31) ^ hash(self.location)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MetamodelParserDetails:
    """
  Attributes:
   - fileExtensions
   - identifier
  """

    thrift_spec = (
        None,  # 0
        (1, TType.SET, "fileExtensions", (TType.STRING, None), None,),  # 1
        (2, TType.STRING, "identifier", None, None,),  # 2
    )

    def __init__(
        self, fileExtensions=None, identifier=None,
    ):
        self.fileExtensions = fileExtensions
        self.identifier = identifier

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.SET:
                    self.fileExtensions = set()
                    (_etype3, _size0) = iprot.readSetBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readString()
                        self.fileExtensions.add(_elem5)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.identifier = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("MetamodelParserDetails")
        if self.fileExtensions is not None:
            oprot.writeFieldBegin("fileExtensions", TType.SET, 1)
            oprot.writeSetBegin(TType.STRING, len(self.fileExtensions))
            for iter6 in self.fileExtensions:
                oprot.writeString(iter6)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.identifier is not None:
            oprot.writeFieldBegin("identifier", TType.STRING, 2)
            oprot.writeString(self.identifier)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.fileExtensions is None:
            raise TProtocol.TProtocolException(
                message="Required field fileExtensions is unset!"
            )
        if self.identifier is None:
            raise TProtocol.TProtocolException(
                message="Required field identifier is unset!"
            )
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.fileExtensions)
        value = (value * 31) ^ hash(self.identifier)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MixedReference:
    """
  Attributes:
   - id
   - position
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "id", None, None,),  # 1
        (2, TType.I32, "position", None, None,),  # 2
    )

    def __init__(
        self, id=None, position=None,
    ):
        self.id = id
        self.position = position

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.id = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.position = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("MixedReference")
        if self.id is not None:
            oprot.writeFieldBegin("id", TType.STRING, 1)
            oprot.writeString(self.id)
            oprot.writeFieldEnd()
        if self.position is not None:
            oprot.writeFieldBegin("position", TType.I32, 2)
            oprot.writeI32(self.position)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.id)
        value = (value * 31) ^ hash(self.position)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ModelSpec:
    """
  Attributes:
   - uri
   - metamodelUris
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "uri", None, None,),  # 1
        (2, TType.LIST, "metamodelUris", (TType.STRING, None), None,),  # 2
    )

    def __init__(
        self, uri=None, metamodelUris=None,
    ):
        self.uri = uri
        self.metamodelUris = metamodelUris

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.uri = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.metamodelUris = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = iprot.readString()
                        self.metamodelUris.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("ModelSpec")
        if self.uri is not None:
            oprot.writeFieldBegin("uri", TType.STRING, 1)
            oprot.writeString(self.uri)
            oprot.writeFieldEnd()
        if self.metamodelUris is not None:
            oprot.writeFieldBegin("metamodelUris", TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.metamodelUris))
            for iter13 in self.metamodelUris:
                oprot.writeString(iter13)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.uri is None:
            raise TProtocol.TProtocolException(message="Required field uri is unset!")
        if self.metamodelUris is None:
            raise TProtocol.TProtocolException(
                message="Required field metamodelUris is unset!"
            )
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.uri)
        value = (value * 31) ^ hash(self.metamodelUris)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Repository:
    """
  Attributes:
   - uri
   - type
   - isFrozen
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "uri", None, None,),  # 1
        (2, TType.STRING, "type", None, None,),  # 2
        (3, TType.BOOL, "isFrozen", None, False,),  # 3
    )

    def __init__(
        self, uri=None, type=None, isFrozen=thrift_spec[3][4],
    ):
        self.uri = uri
        self.type = type
        self.isFrozen = isFrozen

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.uri = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.type = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.isFrozen = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("Repository")
        if self.uri is not None:
            oprot.writeFieldBegin("uri", TType.STRING, 1)
            oprot.writeString(self.uri)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin("type", TType.STRING, 2)
            oprot.writeString(self.type)
            oprot.writeFieldEnd()
        if self.isFrozen is not None:
            oprot.writeFieldBegin("isFrozen", TType.BOOL, 3)
            oprot.writeBool(self.isFrozen)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.uri is None:
            raise TProtocol.TProtocolException(message="Required field uri is unset!")
        if self.type is None:
            raise TProtocol.TProtocolException(message="Required field type is unset!")
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.uri)
        value = (value * 31) ^ hash(self.type)
        value = (value * 31) ^ hash(self.isFrozen)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Slot:
    """
  Attributes:
   - name
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "name", None, None,),  # 1
    )

    def __init__(
        self, name=None,
    ):
        self.name = name

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("Slot")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocol.TProtocolException(message="Required field name is unset!")
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.name)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SlotMetadata:
    """
  Attributes:
   - name
   - type
   - isMany
   - isOrdered
   - isUnique
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "name", None, None,),  # 1
        (2, TType.STRING, "type", None, None,),  # 2
        (3, TType.BOOL, "isMany", None, None,),  # 3
        (4, TType.BOOL, "isOrdered", None, None,),  # 4
        (5, TType.BOOL, "isUnique", None, None,),  # 5
    )

    def __init__(
        self, name=None, type=None, isMany=None, isOrdered=None, isUnique=None,
    ):
        self.name = name
        self.type = type
        self.isMany = isMany
        self.isOrdered = isOrdered
        self.isUnique = isUnique

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.type = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.isMany = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.isOrdered = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.isUnique = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("SlotMetadata")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin("type", TType.STRING, 2)
            oprot.writeString(self.type)
            oprot.writeFieldEnd()
        if self.isMany is not None:
            oprot.writeFieldBegin("isMany", TType.BOOL, 3)
            oprot.writeBool(self.isMany)
            oprot.writeFieldEnd()
        if self.isOrdered is not None:
            oprot.writeFieldBegin("isOrdered", TType.BOOL, 4)
            oprot.writeBool(self.isOrdered)
            oprot.writeFieldEnd()
        if self.isUnique is not None:
            oprot.writeFieldBegin("isUnique", TType.BOOL, 5)
            oprot.writeBool(self.isUnique)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocol.TProtocolException(message="Required field name is unset!")
        if self.type is None:
            raise TProtocol.TProtocolException(message="Required field type is unset!")
        if self.isMany is None:
            raise TProtocol.TProtocolException(
                message="Required field isMany is unset!"
            )
        if self.isOrdered is None:
            raise TProtocol.TProtocolException(
                message="Required field isOrdered is unset!"
            )
        if self.isUnique is None:
            raise TProtocol.TProtocolException(
                message="Required field isUnique is unset!"
            )
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.name)
        value = (value * 31) ^ hash(self.type)
        value = (value * 31) ^ hash(self.isMany)
        value = (value * 31) ^ hash(self.isOrdered)
        value = (value * 31) ^ hash(self.isUnique)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SlotValue:
    """
  Attributes:
   - vBoolean
   - vByte
   - vShort
   - vInteger
   - vLong
   - vDouble
   - vString
   - vBooleans
   - vBytes
   - vShorts
   - vIntegers
   - vLongs
   - vDoubles
   - vStrings
   - vLists
  """
    thrift_spec = (
        None,  # 0
        (1, TType.BOOL, "vBoolean", None, None,),  # 1
        (2, TType.BYTE, "vByte", None, None,),  # 2
        (3, TType.I16, "vShort", None, None,),  # 3
        (4, TType.I32, "vInteger", None, None,),  # 4
        (5, TType.I64, "vLong", None, None,),  # 5
        (6, TType.DOUBLE, "vDouble", None, None,),  # 6
        (7, TType.STRING, "vString", None, None,),  # 7
        (8, TType.LIST, "vBooleans", (TType.BOOL, None), None,),  # 8
        (9, TType.STRING, "vBytes", None, None,),  # 9
        (10, TType.LIST, "vShorts", (TType.I16, None), None,),  # 10
        (11, TType.LIST, "vIntegers", (TType.I32, None), None,),  # 11
        (12, TType.LIST, "vLongs", (TType.I64, None), None,),  # 12
        (13, TType.LIST, "vDoubles", (TType.DOUBLE, None), None,),  # 13
        (14, TType.LIST, "vStrings", (TType.STRING, None), None,),  # 14
        (
            15,
            TType.LIST,
            "vLists",
            (TType.STRUCT, ('SlotValue', 'SlotValue.thrift_spec')),
            None,
        ),  # 15
    )

    def __init__(
        self,
        vBoolean=None,
        vByte=None,
        vShort=None,
        vInteger=None,
        vLong=None,
        vDouble=None,
        vString=None,
        vBooleans=None,
        vBytes=None,
        vShorts=None,
        vIntegers=None,
        vLongs=None,
        vDoubles=None,
        vStrings=None,
        vLists=None,
    ):
        self.vBoolean = vBoolean
        self.vByte = vByte
        self.vShort = vShort
        self.vInteger = vInteger
        self.vLong = vLong
        self.vDouble = vDouble
        self.vString = vString
        self.vBooleans = vBooleans
        self.vBytes = vBytes
        self.vShorts = vShorts
        self.vIntegers = vIntegers
        self.vLongs = vLongs
        self.vDoubles = vDoubles
        self.vStrings = vStrings
        self.vLists = vLists

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.vBoolean = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.vByte = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.vShort = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.vInteger = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.vLong = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.DOUBLE:
                    self.vDouble = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.vString = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.LIST:
                    self.vBooleans = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = iprot.readBool()
                        self.vBooleans.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.vBytes = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.LIST:
                    self.vShorts = []
                    (_etype23, _size20) = iprot.readListBegin()
                    for _i24 in range(_size20):
                        _elem25 = iprot.readI16()
                        self.vShorts.append(_elem25)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.LIST:
                    self.vIntegers = []
                    (_etype29, _size26) = iprot.readListBegin()
                    for _i30 in range(_size26):
                        _elem31 = iprot.readI32()
                        self.vIntegers.append(_elem31)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.LIST:
                    self.vLongs = []
                    (_etype35, _size32) = iprot.readListBegin()
                    for _i36 in range(_size32):
                        _elem37 = iprot.readI64()
                        self.vLongs.append(_elem37)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.LIST:
                    self.vDoubles = []
                    (_etype41, _size38) = iprot.readListBegin()
                    for _i42 in range(_size38):
                        _elem43 = iprot.readDouble()
                        self.vDoubles.append(_elem43)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.LIST:
                    self.vStrings = []
                    (_etype47, _size44) = iprot.readListBegin()
                    for _i48 in range(_size44):
                        _elem49 = iprot.readString()
                        self.vStrings.append(_elem49)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.LIST:
                    self.vLists = []
                    (_etype53, _size50) = iprot.readListBegin()
                    for _i54 in range(_size50):
                        _elem55 = SlotValue()
                        _elem55.read(iprot)
                        self.vLists.append(_elem55)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("SlotValue")
        if self.vBoolean is not None:
            oprot.writeFieldBegin("vBoolean", TType.BOOL, 1)
            oprot.writeBool(self.vBoolean)
            oprot.writeFieldEnd()
        if self.vByte is not None:
            oprot.writeFieldBegin("vByte", TType.BYTE, 2)
            oprot.writeByte(self.vByte)
            oprot.writeFieldEnd()
        if self.vShort is not None:
            oprot.writeFieldBegin("vShort", TType.I16, 3)
            oprot.writeI16(self.vShort)
            oprot.writeFieldEnd()
        if self.vInteger is not None:
            oprot.writeFieldBegin("vInteger", TType.I32, 4)
            oprot.writeI32(self.vInteger)
            oprot.writeFieldEnd()
        if self.vLong is not None:
            oprot.writeFieldBegin("vLong", TType.I64, 5)
            oprot.writeI64(self.vLong)
            oprot.writeFieldEnd()
        if self.vDouble is not None:
            oprot.writeFieldBegin("vDouble", TType.DOUBLE, 6)
            oprot.writeDouble(self.vDouble)
            oprot.writeFieldEnd()
        if self.vString is not None:
            oprot.writeFieldBegin("vString", TType.STRING, 7)
            oprot.writeString(self.vString)
            oprot.writeFieldEnd()
        if self.vBooleans is not None:
            oprot.writeFieldBegin("vBooleans", TType.LIST, 8)
            oprot.writeListBegin(TType.BOOL, len(self.vBooleans))
            for iter56 in self.vBooleans:
                oprot.writeBool(iter56)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.vBytes is not None:
            oprot.writeFieldBegin("vBytes", TType.STRING, 9)
            oprot.writeString(self.vBytes)
            oprot.writeFieldEnd()
        if self.vShorts is not None:
            oprot.writeFieldBegin("vShorts", TType.LIST, 10)
            oprot.writeListBegin(TType.I16, len(self.vShorts))
            for iter57 in self.vShorts:
                oprot.writeI16(iter57)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.vIntegers is not None:
            oprot.writeFieldBegin("vIntegers", TType.LIST, 11)
            oprot.writeListBegin(TType.I32, len(self.vIntegers))
            for iter58 in self.vIntegers:
                oprot.writeI32(iter58)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.vLongs is not None:
            oprot.writeFieldBegin("vLongs", TType.LIST, 12)
            oprot.writeListBegin(TType.I64, len(self.vLongs))
            for iter59 in self.vLongs:
                oprot.writeI64(iter59)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.vDoubles is not None:
            oprot.writeFieldBegin("vDoubles", TType.LIST, 13)
            oprot.writeListBegin(TType.DOUBLE, len(self.vDoubles))
            for iter60 in self.vDoubles:
                oprot.writeDouble(iter60)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.vStrings is not None:
            oprot.writeFieldBegin("vStrings", TType.LIST, 14)
            oprot.writeListBegin(TType.STRING, len(self.vStrings))
            for iter61 in self.vStrings:
                oprot.writeString(iter61)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.vLists is not None:
            oprot.writeFieldBegin("vLists", TType.LIST, 15)
            oprot.writeListBegin(TType.STRUCT, len(self.vLists))
            for iter62 in self.vLists:
                iter62.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.vBoolean)
        value = (value * 31) ^ hash(self.vByte)
        value = (value * 31) ^ hash(self.vShort)
        value = (value * 31) ^ hash(self.vInteger)
        value = (value * 31) ^ hash(self.vLong)
        value = (value * 31) ^ hash(self.vDouble)
        value = (value * 31) ^ hash(self.vString)
        value = (value * 31) ^ hash(self.vBooleans)
        value = (value * 31) ^ hash(self.vBytes)
        value = (value * 31) ^ hash(self.vShorts)
        value = (value * 31) ^ hash(self.vIntegers)
        value = (value * 31) ^ hash(self.vLongs)
        value = (value * 31) ^ hash(self.vDoubles)
        value = (value * 31) ^ hash(self.vStrings)
        value = (value * 31) ^ hash(self.vLists)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Subscription:
    """
  Attributes:
   - host
   - port
   - queueAddress
   - queueName
   - sslRequired
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "host", None, None,),  # 1
        (2, TType.I32, "port", None, None,),  # 2
        (3, TType.STRING, "queueAddress", None, None,),  # 3
        (4, TType.STRING, "queueName", None, None,),  # 4
        (5, TType.BOOL, "sslRequired", None, False,),  # 5
    )

    def __init__(
        self,
        host=None,
        port=None,
        queueAddress=None,
        queueName=None,
        sslRequired=thrift_spec[5][4],
    ):
        self.host = host
        self.port = port
        self.queueAddress = queueAddress
        self.queueName = queueName
        self.sslRequired = sslRequired

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.host = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.queueAddress = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.queueName = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.sslRequired = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("Subscription")
        if self.host is not None:
            oprot.writeFieldBegin("host", TType.STRING, 1)
            oprot.writeString(self.host)
            oprot.writeFieldEnd()
        if self.port is not None:
            oprot.writeFieldBegin("port", TType.I32, 2)
            oprot.writeI32(self.port)
            oprot.writeFieldEnd()
        if self.queueAddress is not None:
            oprot.writeFieldBegin("queueAddress", TType.STRING, 3)
            oprot.writeString(self.queueAddress)
            oprot.writeFieldEnd()
        if self.queueName is not None:
            oprot.writeFieldBegin("queueName", TType.STRING, 4)
            oprot.writeString(self.queueName)
            oprot.writeFieldEnd()
        if self.sslRequired is not None:
            oprot.writeFieldBegin("sslRequired", TType.BOOL, 5)
            oprot.writeBool(self.sslRequired)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.host is None:
            raise TProtocol.TProtocolException(message="Required field host is unset!")
        if self.port is None:
            raise TProtocol.TProtocolException(message="Required field port is unset!")
        if self.queueAddress is None:
            raise TProtocol.TProtocolException(
                message="Required field queueAddress is unset!"
            )
        if self.queueName is None:
            raise TProtocol.TProtocolException(
                message="Required field queueName is unset!"
            )
        if self.sslRequired is None:
            raise TProtocol.TProtocolException(
                message="Required field sslRequired is unset!"
            )
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.host)
        value = (value * 31) ^ hash(self.port)
        value = (value * 31) ^ hash(self.queueAddress)
        value = (value * 31) ^ hash(self.queueName)
        value = (value * 31) ^ hash(self.sslRequired)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class UnknownQueryLanguage(TException):
    """
  Attributes:
   - queryLanguage
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "queryLanguage", None, None,),  # 1
    )

    def __init__(
        self, queryLanguage=None,
    ):
        self.queryLanguage = queryLanguage

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.queryLanguage = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("UnknownQueryLanguage")
        if self.queryLanguage is not None:
            oprot.writeFieldBegin("queryLanguage", TType.STRING, 1)
            oprot.writeString(self.queryLanguage)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.queryLanguage)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class UnknownRepositoryType(TException):
    """
  Attributes:
   - repositoryType
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "repositoryType", None, None,),  # 1
    )

    def __init__(
        self, repositoryType=None,
    ):
        self.repositoryType = repositoryType

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.repositoryType = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("UnknownRepositoryType")
        if self.repositoryType is not None:
            oprot.writeFieldBegin("repositoryType", TType.STRING, 1)
            oprot.writeString(self.repositoryType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.repositoryType)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class UserExists(TException):

    thrift_spec = ()

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("UserExists")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class UserNotFound(TException):

    thrift_spec = ()

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("UserNotFound")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class UserProfile:
    """
  Attributes:
   - realName
   - admin
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "realName", None, None,),  # 1
        (2, TType.BOOL, "admin", None, None,),  # 2
    )

    def __init__(
        self, realName=None, admin=None,
    ):
        self.realName = realName
        self.admin = admin

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.realName = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.admin = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("UserProfile")
        if self.realName is not None:
            oprot.writeFieldBegin("realName", TType.STRING, 1)
            oprot.writeString(self.realName)
            oprot.writeFieldEnd()
        if self.admin is not None:
            oprot.writeFieldBegin("admin", TType.BOOL, 2)
            oprot.writeBool(self.admin)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.realName is None:
            raise TProtocol.TProtocolException(
                message="Required field realName is unset!"
            )
        if self.admin is None:
            raise TProtocol.TProtocolException(message="Required field admin is unset!")
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.realName)
        value = (value * 31) ^ hash(self.admin)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class VCSAuthenticationFailed(TException):

    thrift_spec = ()

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("VCSAuthenticationFailed")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Value:
    """
  Attributes:
   - vBoolean
   - vByte
   - vShort
   - vInteger
   - vLong
   - vDouble
   - vString
  """

    thrift_spec = (
        None,  # 0
        (1, TType.BOOL, "vBoolean", None, None,),  # 1
        (2, TType.BYTE, "vByte", None, None,),  # 2
        (3, TType.I16, "vShort", None, None,),  # 3
        (4, TType.I32, "vInteger", None, None,),  # 4
        (5, TType.I64, "vLong", None, None,),  # 5
        (6, TType.DOUBLE, "vDouble", None, None,),  # 6
        (7, TType.STRING, "vString", None, None,),  # 7
    )

    def __init__(
        self,
        vBoolean=None,
        vByte=None,
        vShort=None,
        vInteger=None,
        vLong=None,
        vDouble=None,
        vString=None,
    ):
        self.vBoolean = vBoolean
        self.vByte = vByte
        self.vShort = vShort
        self.vInteger = vInteger
        self.vLong = vLong
        self.vDouble = vDouble
        self.vString = vString

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.vBoolean = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.vByte = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.vShort = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.vInteger = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.vLong = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.DOUBLE:
                    self.vDouble = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.vString = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("Value")
        if self.vBoolean is not None:
            oprot.writeFieldBegin("vBoolean", TType.BOOL, 1)
            oprot.writeBool(self.vBoolean)
            oprot.writeFieldEnd()
        if self.vByte is not None:
            oprot.writeFieldBegin("vByte", TType.BYTE, 2)
            oprot.writeByte(self.vByte)
            oprot.writeFieldEnd()
        if self.vShort is not None:
            oprot.writeFieldBegin("vShort", TType.I16, 3)
            oprot.writeI16(self.vShort)
            oprot.writeFieldEnd()
        if self.vInteger is not None:
            oprot.writeFieldBegin("vInteger", TType.I32, 4)
            oprot.writeI32(self.vInteger)
            oprot.writeFieldEnd()
        if self.vLong is not None:
            oprot.writeFieldBegin("vLong", TType.I64, 5)
            oprot.writeI64(self.vLong)
            oprot.writeFieldEnd()
        if self.vDouble is not None:
            oprot.writeFieldBegin("vDouble", TType.DOUBLE, 6)
            oprot.writeDouble(self.vDouble)
            oprot.writeFieldEnd()
        if self.vString is not None:
            oprot.writeFieldBegin("vString", TType.STRING, 7)
            oprot.writeString(self.vString)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.vBoolean)
        value = (value * 31) ^ hash(self.vByte)
        value = (value * 31) ^ hash(self.vShort)
        value = (value * 31) ^ hash(self.vInteger)
        value = (value * 31) ^ hash(self.vLong)
        value = (value * 31) ^ hash(self.vDouble)
        value = (value * 31) ^ hash(self.vString)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class AttributeSlot:
    """
  Attributes:
   - name
   - value
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "name", None, None,),  # 1
        (2, TType.STRUCT, "value", (SlotValue, SlotValue.thrift_spec), None,),  # 2
    )

    def __init__(
        self, name=None, value=None,
    ):
        self.name = name
        self.value = value

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.value = SlotValue()
                    self.value.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("AttributeSlot")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin("value", TType.STRUCT, 2)
            self.value.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocol.TProtocolException(message="Required field name is unset!")
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.name)
        value = (value * 31) ^ hash(self.value)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class HawkAttributeRemovalEvent:
    """
  Attributes:
   - vcsItem
   - id
   - attribute
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, "vcsItem", (CommitItem, CommitItem.thrift_spec), None,),  # 1
        (2, TType.STRING, "id", None, None,),  # 2
        (3, TType.STRING, "attribute", None, None,),  # 3
    )

    def __init__(
        self, vcsItem=None, id=None, attribute=None,
    ):
        self.vcsItem = vcsItem
        self.id = id
        self.attribute = attribute

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.vcsItem = CommitItem()
                    self.vcsItem.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.id = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.attribute = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("HawkAttributeRemovalEvent")
        if self.vcsItem is not None:
            oprot.writeFieldBegin("vcsItem", TType.STRUCT, 1)
            self.vcsItem.write(oprot)
            oprot.writeFieldEnd()
        if self.id is not None:
            oprot.writeFieldBegin("id", TType.STRING, 2)
            oprot.writeString(self.id)
            oprot.writeFieldEnd()
        if self.attribute is not None:
            oprot.writeFieldBegin("attribute", TType.STRING, 3)
            oprot.writeString(self.attribute)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.vcsItem is None:
            raise TProtocol.TProtocolException(
                message="Required field vcsItem is unset!"
            )
        if self.id is None:
            raise TProtocol.TProtocolException(message="Required field id is unset!")
        if self.attribute is None:
            raise TProtocol.TProtocolException(
                message="Required field attribute is unset!"
            )
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.vcsItem)
        value = (value * 31) ^ hash(self.id)
        value = (value * 31) ^ hash(self.attribute)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class HawkAttributeUpdateEvent:
    """
  Attributes:
   - vcsItem
   - id
   - attribute
   - value
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, "vcsItem", (CommitItem, CommitItem.thrift_spec), None,),  # 1
        (2, TType.STRING, "id", None, None,),  # 2
        (3, TType.STRING, "attribute", None, None,),  # 3
        (4, TType.STRUCT, "value", (SlotValue, SlotValue.thrift_spec), None,),  # 4
    )

    def __init__(
        self, vcsItem=None, id=None, attribute=None, value=None,
    ):
        self.vcsItem = vcsItem
        self.id = id
        self.attribute = attribute
        self.value = value

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.vcsItem = CommitItem()
                    self.vcsItem.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.id = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.attribute = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.value = SlotValue()
                    self.value.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("HawkAttributeUpdateEvent")
        if self.vcsItem is not None:
            oprot.writeFieldBegin("vcsItem", TType.STRUCT, 1)
            self.vcsItem.write(oprot)
            oprot.writeFieldEnd()
        if self.id is not None:
            oprot.writeFieldBegin("id", TType.STRING, 2)
            oprot.writeString(self.id)
            oprot.writeFieldEnd()
        if self.attribute is not None:
            oprot.writeFieldBegin("attribute", TType.STRING, 3)
            oprot.writeString(self.attribute)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin("value", TType.STRUCT, 4)
            self.value.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.vcsItem is None:
            raise TProtocol.TProtocolException(
                message="Required field vcsItem is unset!"
            )
        if self.id is None:
            raise TProtocol.TProtocolException(message="Required field id is unset!")
        if self.attribute is None:
            raise TProtocol.TProtocolException(
                message="Required field attribute is unset!"
            )
        if self.value is None:
            raise TProtocol.TProtocolException(message="Required field value is unset!")
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.vcsItem)
        value = (value * 31) ^ hash(self.id)
        value = (value * 31) ^ hash(self.attribute)
        value = (value * 31) ^ hash(self.value)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class HawkFileAdditionEvent:
    """
  Attributes:
   - vcsItem
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, "vcsItem", (CommitItem, CommitItem.thrift_spec), None,),  # 1
    )

    def __init__(
        self, vcsItem=None,
    ):
        self.vcsItem = vcsItem

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.vcsItem = CommitItem()
                    self.vcsItem.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("HawkFileAdditionEvent")
        if self.vcsItem is not None:
            oprot.writeFieldBegin("vcsItem", TType.STRUCT, 1)
            self.vcsItem.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.vcsItem is None:
            raise TProtocol.TProtocolException(
                message="Required field vcsItem is unset!"
            )
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.vcsItem)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class HawkFileRemovalEvent:
    """
  Attributes:
   - vcsItem
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, "vcsItem", (CommitItem, CommitItem.thrift_spec), None,),  # 1
    )

    def __init__(
        self, vcsItem=None,
    ):
        self.vcsItem = vcsItem

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.vcsItem = CommitItem()
                    self.vcsItem.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("HawkFileRemovalEvent")
        if self.vcsItem is not None:
            oprot.writeFieldBegin("vcsItem", TType.STRUCT, 1)
            self.vcsItem.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.vcsItem is None:
            raise TProtocol.TProtocolException(
                message="Required field vcsItem is unset!"
            )
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.vcsItem)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class HawkModelElementAdditionEvent:
    """
  Attributes:
   - vcsItem
   - metamodelURI
   - typeName
   - id
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, "vcsItem", (CommitItem, CommitItem.thrift_spec), None,),  # 1
        (2, TType.STRING, "metamodelURI", None, None,),  # 2
        (3, TType.STRING, "typeName", None, None,),  # 3
        (4, TType.STRING, "id", None, None,),  # 4
    )

    def __init__(
        self, vcsItem=None, metamodelURI=None, typeName=None, id=None,
    ):
        self.vcsItem = vcsItem
        self.metamodelURI = metamodelURI
        self.typeName = typeName
        self.id = id

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.vcsItem = CommitItem()
                    self.vcsItem.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.metamodelURI = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.typeName = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.id = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("HawkModelElementAdditionEvent")
        if self.vcsItem is not None:
            oprot.writeFieldBegin("vcsItem", TType.STRUCT, 1)
            self.vcsItem.write(oprot)
            oprot.writeFieldEnd()
        if self.metamodelURI is not None:
            oprot.writeFieldBegin("metamodelURI", TType.STRING, 2)
            oprot.writeString(self.metamodelURI)
            oprot.writeFieldEnd()
        if self.typeName is not None:
            oprot.writeFieldBegin("typeName", TType.STRING, 3)
            oprot.writeString(self.typeName)
            oprot.writeFieldEnd()
        if self.id is not None:
            oprot.writeFieldBegin("id", TType.STRING, 4)
            oprot.writeString(self.id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.vcsItem is None:
            raise TProtocol.TProtocolException(
                message="Required field vcsItem is unset!"
            )
        if self.metamodelURI is None:
            raise TProtocol.TProtocolException(
                message="Required field metamodelURI is unset!"
            )
        if self.typeName is None:
            raise TProtocol.TProtocolException(
                message="Required field typeName is unset!"
            )
        if self.id is None:
            raise TProtocol.TProtocolException(message="Required field id is unset!")
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.vcsItem)
        value = (value * 31) ^ hash(self.metamodelURI)
        value = (value * 31) ^ hash(self.typeName)
        value = (value * 31) ^ hash(self.id)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class HawkModelElementRemovalEvent:
    """
  Attributes:
   - vcsItem
   - id
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, "vcsItem", (CommitItem, CommitItem.thrift_spec), None,),  # 1
        (2, TType.STRING, "id", None, None,),  # 2
    )

    def __init__(
        self, vcsItem=None, id=None,
    ):
        self.vcsItem = vcsItem
        self.id = id

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.vcsItem = CommitItem()
                    self.vcsItem.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.id = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("HawkModelElementRemovalEvent")
        if self.vcsItem is not None:
            oprot.writeFieldBegin("vcsItem", TType.STRUCT, 1)
            self.vcsItem.write(oprot)
            oprot.writeFieldEnd()
        if self.id is not None:
            oprot.writeFieldBegin("id", TType.STRING, 2)
            oprot.writeString(self.id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.vcsItem is None:
            raise TProtocol.TProtocolException(
                message="Required field vcsItem is unset!"
            )
        if self.id is None:
            raise TProtocol.TProtocolException(message="Required field id is unset!")
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.vcsItem)
        value = (value * 31) ^ hash(self.id)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class HawkReferenceAdditionEvent:
    """
  Attributes:
   - vcsItem
   - sourceId
   - targetId
   - refName
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, "vcsItem", (CommitItem, CommitItem.thrift_spec), None,),  # 1
        (2, TType.STRING, "sourceId", None, None,),  # 2
        (3, TType.STRING, "targetId", None, None,),  # 3
        (4, TType.STRING, "refName", None, None,),  # 4
    )

    def __init__(
        self, vcsItem=None, sourceId=None, targetId=None, refName=None,
    ):
        self.vcsItem = vcsItem
        self.sourceId = sourceId
        self.targetId = targetId
        self.refName = refName

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.vcsItem = CommitItem()
                    self.vcsItem.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.sourceId = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.targetId = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.refName = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("HawkReferenceAdditionEvent")
        if self.vcsItem is not None:
            oprot.writeFieldBegin("vcsItem", TType.STRUCT, 1)
            self.vcsItem.write(oprot)
            oprot.writeFieldEnd()
        if self.sourceId is not None:
            oprot.writeFieldBegin("sourceId", TType.STRING, 2)
            oprot.writeString(self.sourceId)
            oprot.writeFieldEnd()
        if self.targetId is not None:
            oprot.writeFieldBegin("targetId", TType.STRING, 3)
            oprot.writeString(self.targetId)
            oprot.writeFieldEnd()
        if self.refName is not None:
            oprot.writeFieldBegin("refName", TType.STRING, 4)
            oprot.writeString(self.refName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.vcsItem is None:
            raise TProtocol.TProtocolException(
                message="Required field vcsItem is unset!"
            )
        if self.sourceId is None:
            raise TProtocol.TProtocolException(
                message="Required field sourceId is unset!"
            )
        if self.targetId is None:
            raise TProtocol.TProtocolException(
                message="Required field targetId is unset!"
            )
        if self.refName is None:
            raise TProtocol.TProtocolException(
                message="Required field refName is unset!"
            )
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.vcsItem)
        value = (value * 31) ^ hash(self.sourceId)
        value = (value * 31) ^ hash(self.targetId)
        value = (value * 31) ^ hash(self.refName)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class HawkReferenceRemovalEvent:
    """
  Attributes:
   - vcsItem
   - sourceId
   - targetId
   - refName
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, "vcsItem", (CommitItem, CommitItem.thrift_spec), None,),  # 1
        (2, TType.STRING, "sourceId", None, None,),  # 2
        (3, TType.STRING, "targetId", None, None,),  # 3
        (4, TType.STRING, "refName", None, None,),  # 4
    )

    def __init__(
        self, vcsItem=None, sourceId=None, targetId=None, refName=None,
    ):
        self.vcsItem = vcsItem
        self.sourceId = sourceId
        self.targetId = targetId
        self.refName = refName

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.vcsItem = CommitItem()
                    self.vcsItem.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.sourceId = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.targetId = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.refName = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("HawkReferenceRemovalEvent")
        if self.vcsItem is not None:
            oprot.writeFieldBegin("vcsItem", TType.STRUCT, 1)
            self.vcsItem.write(oprot)
            oprot.writeFieldEnd()
        if self.sourceId is not None:
            oprot.writeFieldBegin("sourceId", TType.STRING, 2)
            oprot.writeString(self.sourceId)
            oprot.writeFieldEnd()
        if self.targetId is not None:
            oprot.writeFieldBegin("targetId", TType.STRING, 3)
            oprot.writeString(self.targetId)
            oprot.writeFieldEnd()
        if self.refName is not None:
            oprot.writeFieldBegin("refName", TType.STRING, 4)
            oprot.writeString(self.refName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.vcsItem is None:
            raise TProtocol.TProtocolException(
                message="Required field vcsItem is unset!"
            )
        if self.sourceId is None:
            raise TProtocol.TProtocolException(
                message="Required field sourceId is unset!"
            )
        if self.targetId is None:
            raise TProtocol.TProtocolException(
                message="Required field targetId is unset!"
            )
        if self.refName is None:
            raise TProtocol.TProtocolException(
                message="Required field refName is unset!"
            )
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.vcsItem)
        value = (value * 31) ^ hash(self.sourceId)
        value = (value * 31) ^ hash(self.targetId)
        value = (value * 31) ^ hash(self.refName)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InvalidModelSpec:
    """
  Attributes:
   - spec
   - reason
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, "spec", (ModelSpec, ModelSpec.thrift_spec), None,),  # 1
        (2, TType.STRING, "reason", None, None,),  # 2
    )

    def __init__(
        self, spec=None, reason=None,
    ):
        self.spec = spec
        self.reason = reason

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.spec = ModelSpec()
                    self.spec.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.reason = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("InvalidModelSpec")
        if self.spec is not None:
            oprot.writeFieldBegin("spec", TType.STRUCT, 1)
            self.spec.write(oprot)
            oprot.writeFieldEnd()
        if self.reason is not None:
            oprot.writeFieldBegin("reason", TType.STRING, 2)
            oprot.writeString(self.reason)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.spec is None:
            raise TProtocol.TProtocolException(message="Required field spec is unset!")
        if self.reason is None:
            raise TProtocol.TProtocolException(
                message="Required field reason is unset!"
            )
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.spec)
        value = (value * 31) ^ hash(self.reason)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ModelElementType:
    """
  Attributes:
   - id
   - metamodelUri
   - typeName
   - attributes
   - references
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "id", None, None,),  # 1
        (2, TType.STRING, "metamodelUri", None, None,),  # 2
        (3, TType.STRING, "typeName", None, None,),  # 3
        (
            4,
            TType.LIST,
            "attributes",
            (TType.STRUCT, (SlotMetadata, SlotMetadata.thrift_spec)),
            None,
        ),  # 4
        (
            5,
            TType.LIST,
            "references",
            (TType.STRUCT, (SlotMetadata, SlotMetadata.thrift_spec)),
            None,
        ),  # 5
    )

    def __init__(
        self,
        id=None,
        metamodelUri=None,
        typeName=None,
        attributes=None,
        references=None,
    ):
        self.id = id
        self.metamodelUri = metamodelUri
        self.typeName = typeName
        self.attributes = attributes
        self.references = references

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.id = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.metamodelUri = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.typeName = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.attributes = []
                    (_etype66, _size63) = iprot.readListBegin()
                    for _i67 in range(_size63):
                        _elem68 = SlotMetadata()
                        _elem68.read(iprot)
                        self.attributes.append(_elem68)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.references = []
                    (_etype72, _size69) = iprot.readListBegin()
                    for _i73 in range(_size69):
                        _elem74 = SlotMetadata()
                        _elem74.read(iprot)
                        self.references.append(_elem74)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("ModelElementType")
        if self.id is not None:
            oprot.writeFieldBegin("id", TType.STRING, 1)
            oprot.writeString(self.id)
            oprot.writeFieldEnd()
        if self.metamodelUri is not None:
            oprot.writeFieldBegin("metamodelUri", TType.STRING, 2)
            oprot.writeString(self.metamodelUri)
            oprot.writeFieldEnd()
        if self.typeName is not None:
            oprot.writeFieldBegin("typeName", TType.STRING, 3)
            oprot.writeString(self.typeName)
            oprot.writeFieldEnd()
        if self.attributes is not None:
            oprot.writeFieldBegin("attributes", TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.attributes))
            for iter75 in self.attributes:
                iter75.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.references is not None:
            oprot.writeFieldBegin("references", TType.LIST, 5)
            oprot.writeListBegin(TType.STRUCT, len(self.references))
            for iter76 in self.references:
                iter76.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.id is None:
            raise TProtocol.TProtocolException(message="Required field id is unset!")
        if self.metamodelUri is None:
            raise TProtocol.TProtocolException(
                message="Required field metamodelUri is unset!"
            )
        if self.typeName is None:
            raise TProtocol.TProtocolException(
                message="Required field typeName is unset!"
            )
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.id)
        value = (value * 31) ^ hash(self.metamodelUri)
        value = (value * 31) ^ hash(self.typeName)
        value = (value * 31) ^ hash(self.attributes)
        value = (value * 31) ^ hash(self.references)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ReferenceSlot:
    """
  Attributes:
   - name
   - position
   - positions
   - id
   - ids
   - mixed
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "name", None, None,),  # 1
        (2, TType.I32, "position", None, None,),  # 2
        (3, TType.LIST, "positions", (TType.I32, None), None,),  # 3
        (4, TType.STRING, "id", None, None,),  # 4
        (5, TType.LIST, "ids", (TType.STRING, None), None,),  # 5
        (
            6,
            TType.LIST,
            "mixed",
            (TType.STRUCT, (MixedReference, MixedReference.thrift_spec)),
            None,
        ),  # 6
    )

    def __init__(
        self, name=None, position=None, positions=None, id=None, ids=None, mixed=None,
    ):
        self.name = name
        self.position = position
        self.positions = positions
        self.id = id
        self.ids = ids
        self.mixed = mixed

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.position = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.positions = []
                    (_etype80, _size77) = iprot.readListBegin()
                    for _i81 in range(_size77):
                        _elem82 = iprot.readI32()
                        self.positions.append(_elem82)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.id = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.ids = []
                    (_etype86, _size83) = iprot.readListBegin()
                    for _i87 in range(_size83):
                        _elem88 = iprot.readString()
                        self.ids.append(_elem88)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.mixed = []
                    (_etype92, _size89) = iprot.readListBegin()
                    for _i93 in range(_size89):
                        _elem94 = MixedReference()
                        _elem94.read(iprot)
                        self.mixed.append(_elem94)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("ReferenceSlot")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        if self.position is not None:
            oprot.writeFieldBegin("position", TType.I32, 2)
            oprot.writeI32(self.position)
            oprot.writeFieldEnd()
        if self.positions is not None:
            oprot.writeFieldBegin("positions", TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.positions))
            for iter95 in self.positions:
                oprot.writeI32(iter95)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.id is not None:
            oprot.writeFieldBegin("id", TType.STRING, 4)
            oprot.writeString(self.id)
            oprot.writeFieldEnd()
        if self.ids is not None:
            oprot.writeFieldBegin("ids", TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.ids))
            for iter96 in self.ids:
                oprot.writeString(iter96)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.mixed is not None:
            oprot.writeFieldBegin("mixed", TType.LIST, 6)
            oprot.writeListBegin(TType.STRUCT, len(self.mixed))
            for iter97 in self.mixed:
                iter97.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocol.TProtocolException(message="Required field name is unset!")
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.name)
        value = (value * 31) ^ hash(self.position)
        value = (value * 31) ^ hash(self.positions)
        value = (value * 31) ^ hash(self.id)
        value = (value * 31) ^ hash(self.ids)
        value = (value * 31) ^ hash(self.mixed)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class HawkChangeEvent:
    """
  Attributes:
   - modelElementAddition
   - modelElementRemoval
   - modelElementAttributeUpdate
   - modelElementAttributeRemoval
   - referenceAddition
   - referenceRemoval
   - syncStart
   - syncEnd
   - fileAddition
   - fileRemoval
  """

    thrift_spec = (
        None,  # 0
        (
            1,
            TType.STRUCT,
            "modelElementAddition",
            (HawkModelElementAdditionEvent, HawkModelElementAdditionEvent.thrift_spec),
            None,
        ),  # 1
        (
            2,
            TType.STRUCT,
            "modelElementRemoval",
            (HawkModelElementRemovalEvent, HawkModelElementRemovalEvent.thrift_spec),
            None,
        ),  # 2
        (
            3,
            TType.STRUCT,
            "modelElementAttributeUpdate",
            (HawkAttributeUpdateEvent, HawkAttributeUpdateEvent.thrift_spec),
            None,
        ),  # 3
        (
            4,
            TType.STRUCT,
            "modelElementAttributeRemoval",
            (HawkAttributeRemovalEvent, HawkAttributeRemovalEvent.thrift_spec),
            None,
        ),  # 4
        (
            5,
            TType.STRUCT,
            "referenceAddition",
            (HawkReferenceAdditionEvent, HawkReferenceAdditionEvent.thrift_spec),
            None,
        ),  # 5
        (
            6,
            TType.STRUCT,
            "referenceRemoval",
            (HawkReferenceRemovalEvent, HawkReferenceRemovalEvent.thrift_spec),
            None,
        ),  # 6
        (
            7,
            TType.STRUCT,
            "syncStart",
            (HawkSynchronizationStartEvent, HawkSynchronizationStartEvent.thrift_spec),
            None,
        ),  # 7
        (
            8,
            TType.STRUCT,
            "syncEnd",
            (HawkSynchronizationEndEvent, HawkSynchronizationEndEvent.thrift_spec),
            None,
        ),  # 8
        (
            9,
            TType.STRUCT,
            "fileAddition",
            (HawkFileAdditionEvent, HawkFileAdditionEvent.thrift_spec),
            None,
        ),  # 9
        (
            10,
            TType.STRUCT,
            "fileRemoval",
            (HawkFileRemovalEvent, HawkFileRemovalEvent.thrift_spec),
            None,
        ),  # 10
    )

    def __init__(
        self,
        modelElementAddition=None,
        modelElementRemoval=None,
        modelElementAttributeUpdate=None,
        modelElementAttributeRemoval=None,
        referenceAddition=None,
        referenceRemoval=None,
        syncStart=None,
        syncEnd=None,
        fileAddition=None,
        fileRemoval=None,
    ):
        self.modelElementAddition = modelElementAddition
        self.modelElementRemoval = modelElementRemoval
        self.modelElementAttributeUpdate = modelElementAttributeUpdate
        self.modelElementAttributeRemoval = modelElementAttributeRemoval
        self.referenceAddition = referenceAddition
        self.referenceRemoval = referenceRemoval
        self.syncStart = syncStart
        self.syncEnd = syncEnd
        self.fileAddition = fileAddition
        self.fileRemoval = fileRemoval

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.modelElementAddition = HawkModelElementAdditionEvent()
                    self.modelElementAddition.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.modelElementRemoval = HawkModelElementRemovalEvent()
                    self.modelElementRemoval.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.modelElementAttributeUpdate = HawkAttributeUpdateEvent()
                    self.modelElementAttributeUpdate.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.modelElementAttributeRemoval = HawkAttributeRemovalEvent()
                    self.modelElementAttributeRemoval.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.referenceAddition = HawkReferenceAdditionEvent()
                    self.referenceAddition.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.referenceRemoval = HawkReferenceRemovalEvent()
                    self.referenceRemoval.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.syncStart = HawkSynchronizationStartEvent()
                    self.syncStart.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.syncEnd = HawkSynchronizationEndEvent()
                    self.syncEnd.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRUCT:
                    self.fileAddition = HawkFileAdditionEvent()
                    self.fileAddition.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRUCT:
                    self.fileRemoval = HawkFileRemovalEvent()
                    self.fileRemoval.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("HawkChangeEvent")
        if self.modelElementAddition is not None:
            oprot.writeFieldBegin("modelElementAddition", TType.STRUCT, 1)
            self.modelElementAddition.write(oprot)
            oprot.writeFieldEnd()
        if self.modelElementRemoval is not None:
            oprot.writeFieldBegin("modelElementRemoval", TType.STRUCT, 2)
            self.modelElementRemoval.write(oprot)
            oprot.writeFieldEnd()
        if self.modelElementAttributeUpdate is not None:
            oprot.writeFieldBegin("modelElementAttributeUpdate", TType.STRUCT, 3)
            self.modelElementAttributeUpdate.write(oprot)
            oprot.writeFieldEnd()
        if self.modelElementAttributeRemoval is not None:
            oprot.writeFieldBegin("modelElementAttributeRemoval", TType.STRUCT, 4)
            self.modelElementAttributeRemoval.write(oprot)
            oprot.writeFieldEnd()
        if self.referenceAddition is not None:
            oprot.writeFieldBegin("referenceAddition", TType.STRUCT, 5)
            self.referenceAddition.write(oprot)
            oprot.writeFieldEnd()
        if self.referenceRemoval is not None:
            oprot.writeFieldBegin("referenceRemoval", TType.STRUCT, 6)
            self.referenceRemoval.write(oprot)
            oprot.writeFieldEnd()
        if self.syncStart is not None:
            oprot.writeFieldBegin("syncStart", TType.STRUCT, 7)
            self.syncStart.write(oprot)
            oprot.writeFieldEnd()
        if self.syncEnd is not None:
            oprot.writeFieldBegin("syncEnd", TType.STRUCT, 8)
            self.syncEnd.write(oprot)
            oprot.writeFieldEnd()
        if self.fileAddition is not None:
            oprot.writeFieldBegin("fileAddition", TType.STRUCT, 9)
            self.fileAddition.write(oprot)
            oprot.writeFieldEnd()
        if self.fileRemoval is not None:
            oprot.writeFieldBegin("fileRemoval", TType.STRUCT, 10)
            self.fileRemoval.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.modelElementAddition)
        value = (value * 31) ^ hash(self.modelElementRemoval)
        value = (value * 31) ^ hash(self.modelElementAttributeUpdate)
        value = (value * 31) ^ hash(self.modelElementAttributeRemoval)
        value = (value * 31) ^ hash(self.referenceAddition)
        value = (value * 31) ^ hash(self.referenceRemoval)
        value = (value * 31) ^ hash(self.syncStart)
        value = (value * 31) ^ hash(self.syncEnd)
        value = (value * 31) ^ hash(self.fileAddition)
        value = (value * 31) ^ hash(self.fileRemoval)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class HawkQueryOptions:
    """
  Attributes:
   - repositoryPattern
   - filePatterns
   - defaultNamespaces
   - includeAttributes
   - includeReferences
   - includeNodeIDs
   - includeContained
   - effectiveMetamodelIncludes
   - effectiveMetamodelExcludes
   - includeDerived
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "repositoryPattern", None, "*",),  # 1
        (2, TType.LIST, "filePatterns", (TType.STRING, None), None,),  # 2
        (3, TType.STRING, "defaultNamespaces", None, None,),  # 3
        (4, TType.BOOL, "includeAttributes", None, True,),  # 4
        (5, TType.BOOL, "includeReferences", None, True,),  # 5
        (6, TType.BOOL, "includeNodeIDs", None, False,),  # 6
        (7, TType.BOOL, "includeContained", None, True,),  # 7
        (
            8,
            TType.MAP,
            "effectiveMetamodelIncludes",
            (
                TType.STRING,
                None,
                TType.MAP,
                (TType.STRING, None, TType.SET, (TType.STRING, None)),
            ),
            None,
        ),  # 8
        (
            9,
            TType.MAP,
            "effectiveMetamodelExcludes",
            (
                TType.STRING,
                None,
                TType.MAP,
                (TType.STRING, None, TType.SET, (TType.STRING, None)),
            ),
            None,
        ),  # 9
        (10, TType.BOOL, "includeDerived", None, True,),  # 10
    )

    def __init__(
        self,
        repositoryPattern=thrift_spec[1][4],
        filePatterns=None,
        defaultNamespaces=None,
        includeAttributes=thrift_spec[4][4],
        includeReferences=thrift_spec[5][4],
        includeNodeIDs=thrift_spec[6][4],
        includeContained=thrift_spec[7][4],
        effectiveMetamodelIncludes=None,
        effectiveMetamodelExcludes=None,
        includeDerived=thrift_spec[10][4],
    ):
        self.repositoryPattern = repositoryPattern
        self.filePatterns = filePatterns
        self.defaultNamespaces = defaultNamespaces
        self.includeAttributes = includeAttributes
        self.includeReferences = includeReferences
        self.includeNodeIDs = includeNodeIDs
        self.includeContained = includeContained
        self.effectiveMetamodelIncludes = effectiveMetamodelIncludes
        self.effectiveMetamodelExcludes = effectiveMetamodelExcludes
        self.includeDerived = includeDerived

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.repositoryPattern = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.filePatterns = []
                    (_etype101, _size98) = iprot.readListBegin()
                    for _i102 in range(_size98):
                        _elem103 = iprot.readString()
                        self.filePatterns.append(_elem103)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.defaultNamespaces = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.includeAttributes = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.includeReferences = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.includeNodeIDs = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.includeContained = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.MAP:
                    self.effectiveMetamodelIncludes = {}
                    (_ktype105, _vtype106, _size104) = iprot.readMapBegin()
                    for _i108 in range(_size104):
                        _key109 = iprot.readString()
                        _val110 = {}
                        (_ktype112, _vtype113, _size111) = iprot.readMapBegin()
                        for _i115 in range(_size111):
                            _key116 = iprot.readString()
                            _val117 = set()
                            (_etype121, _size118) = iprot.readSetBegin()
                            for _i122 in range(_size118):
                                _elem123 = iprot.readString()
                                _val117.add(_elem123)
                            iprot.readSetEnd()
                            _val110[_key116] = _val117
                        iprot.readMapEnd()
                        self.effectiveMetamodelIncludes[_key109] = _val110
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.MAP:
                    self.effectiveMetamodelExcludes = {}
                    (_ktype125, _vtype126, _size124) = iprot.readMapBegin()
                    for _i128 in range(_size124):
                        _key129 = iprot.readString()
                        _val130 = {}
                        (_ktype132, _vtype133, _size131) = iprot.readMapBegin()
                        for _i135 in range(_size131):
                            _key136 = iprot.readString()
                            _val137 = set()
                            (_etype141, _size138) = iprot.readSetBegin()
                            for _i142 in range(_size138):
                                _elem143 = iprot.readString()
                                _val137.add(_elem143)
                            iprot.readSetEnd()
                            _val130[_key136] = _val137
                        iprot.readMapEnd()
                        self.effectiveMetamodelExcludes[_key129] = _val130
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.BOOL:
                    self.includeDerived = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("HawkQueryOptions")
        if self.repositoryPattern is not None:
            oprot.writeFieldBegin("repositoryPattern", TType.STRING, 1)
            oprot.writeString(self.repositoryPattern)
            oprot.writeFieldEnd()
        if self.filePatterns is not None:
            oprot.writeFieldBegin("filePatterns", TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.filePatterns))
            for iter144 in self.filePatterns:
                oprot.writeString(iter144)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.defaultNamespaces is not None:
            oprot.writeFieldBegin("defaultNamespaces", TType.STRING, 3)
            oprot.writeString(self.defaultNamespaces)
            oprot.writeFieldEnd()
        if self.includeAttributes is not None:
            oprot.writeFieldBegin("includeAttributes", TType.BOOL, 4)
            oprot.writeBool(self.includeAttributes)
            oprot.writeFieldEnd()
        if self.includeReferences is not None:
            oprot.writeFieldBegin("includeReferences", TType.BOOL, 5)
            oprot.writeBool(self.includeReferences)
            oprot.writeFieldEnd()
        if self.includeNodeIDs is not None:
            oprot.writeFieldBegin("includeNodeIDs", TType.BOOL, 6)
            oprot.writeBool(self.includeNodeIDs)
            oprot.writeFieldEnd()
        if self.includeContained is not None:
            oprot.writeFieldBegin("includeContained", TType.BOOL, 7)
            oprot.writeBool(self.includeContained)
            oprot.writeFieldEnd()
        if self.effectiveMetamodelIncludes is not None:
            oprot.writeFieldBegin("effectiveMetamodelIncludes", TType.MAP, 8)
            oprot.writeMapBegin(
                TType.STRING, TType.MAP, len(self.effectiveMetamodelIncludes)
            )
            for kiter145, viter146 in list(self.effectiveMetamodelIncludes.items()):
                oprot.writeString(kiter145)
                oprot.writeMapBegin(TType.STRING, TType.SET, len(viter146))
                for kiter147, viter148 in list(viter146.items()):
                    oprot.writeString(kiter147)
                    oprot.writeSetBegin(TType.STRING, len(viter148))
                    for iter149 in viter148:
                        oprot.writeString(iter149)
                    oprot.writeSetEnd()
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.effectiveMetamodelExcludes is not None:
            oprot.writeFieldBegin("effectiveMetamodelExcludes", TType.MAP, 9)
            oprot.writeMapBegin(
                TType.STRING, TType.MAP, len(self.effectiveMetamodelExcludes)
            )
            for kiter150, viter151 in list(self.effectiveMetamodelExcludes.items()):
                oprot.writeString(kiter150)
                oprot.writeMapBegin(TType.STRING, TType.SET, len(viter151))
                for kiter152, viter153 in list(viter151.items()):
                    oprot.writeString(kiter152)
                    oprot.writeSetBegin(TType.STRING, len(viter153))
                    for iter154 in viter153:
                        oprot.writeString(iter154)
                    oprot.writeSetEnd()
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.includeDerived is not None:
            oprot.writeFieldBegin("includeDerived", TType.BOOL, 10)
            oprot.writeBool(self.includeDerived)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.repositoryPattern)
        value = (value * 31) ^ hash(self.filePatterns)
        value = (value * 31) ^ hash(self.defaultNamespaces)
        value = (value * 31) ^ hash(self.includeAttributes)
        value = (value * 31) ^ hash(self.includeReferences)
        value = (value * 31) ^ hash(self.includeNodeIDs)
        value = (value * 31) ^ hash(self.includeContained)
        value = (value * 31) ^ hash(self.effectiveMetamodelIncludes)
        value = (value * 31) ^ hash(self.effectiveMetamodelExcludes)
        value = (value * 31) ^ hash(self.includeDerived)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ModelElement:
    """
  Attributes:
   - id
   - repositoryURL
   - file
   - metamodelUri
   - typeName
   - attributes
   - references
   - containers
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "id", None, None,),  # 1
        (2, TType.STRING, "repositoryURL", None, None,),  # 2
        (3, TType.STRING, "file", None, None,),  # 3
        (4, TType.STRING, "metamodelUri", None, None,),  # 4
        (5, TType.STRING, "typeName", None, None,),  # 5
        (
            6,
            TType.LIST,
            "attributes",
            (TType.STRUCT, (AttributeSlot, AttributeSlot.thrift_spec)),
            None,
        ),  # 6
        (
            7,
            TType.LIST,
            "references",
            (TType.STRUCT, (ReferenceSlot, ReferenceSlot.thrift_spec)),
            None,
        ),  # 7
        (
            8,
            TType.LIST,
            "containers",
            (TType.STRUCT, ('ContainerSlot', 'ContainerSlot.thrift_spec')),
            None,
        ),  # 8
    )

    def __init__(
        self,
        id=None,
        repositoryURL=None,
        file=None,
        metamodelUri=None,
        typeName=None,
        attributes=None,
        references=None,
        containers=None,
    ):
        self.id = id
        self.repositoryURL = repositoryURL
        self.file = file
        self.metamodelUri = metamodelUri
        self.typeName = typeName
        self.attributes = attributes
        self.references = references
        self.containers = containers

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.id = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.repositoryURL = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.file = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.metamodelUri = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.typeName = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.attributes = []
                    (_etype158, _size155) = iprot.readListBegin()
                    for _i159 in range(_size155):
                        _elem160 = AttributeSlot()
                        _elem160.read(iprot)
                        self.attributes.append(_elem160)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.references = []
                    (_etype164, _size161) = iprot.readListBegin()
                    for _i165 in range(_size161):
                        _elem166 = ReferenceSlot()
                        _elem166.read(iprot)
                        self.references.append(_elem166)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.LIST:
                    self.containers = []
                    (_etype170, _size167) = iprot.readListBegin()
                    for _i171 in range(_size167):
                        _elem172 = ContainerSlot()
                        _elem172.read(iprot)
                        self.containers.append(_elem172)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("ModelElement")
        if self.id is not None:
            oprot.writeFieldBegin("id", TType.STRING, 1)
            oprot.writeString(self.id)
            oprot.writeFieldEnd()
        if self.repositoryURL is not None:
            oprot.writeFieldBegin("repositoryURL", TType.STRING, 2)
            oprot.writeString(self.repositoryURL)
            oprot.writeFieldEnd()
        if self.file is not None:
            oprot.writeFieldBegin("file", TType.STRING, 3)
            oprot.writeString(self.file)
            oprot.writeFieldEnd()
        if self.metamodelUri is not None:
            oprot.writeFieldBegin("metamodelUri", TType.STRING, 4)
            oprot.writeString(self.metamodelUri)
            oprot.writeFieldEnd()
        if self.typeName is not None:
            oprot.writeFieldBegin("typeName", TType.STRING, 5)
            oprot.writeString(self.typeName)
            oprot.writeFieldEnd()
        if self.attributes is not None:
            oprot.writeFieldBegin("attributes", TType.LIST, 6)
            oprot.writeListBegin(TType.STRUCT, len(self.attributes))
            for iter173 in self.attributes:
                iter173.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.references is not None:
            oprot.writeFieldBegin("references", TType.LIST, 7)
            oprot.writeListBegin(TType.STRUCT, len(self.references))
            for iter174 in self.references:
                iter174.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.containers is not None:
            oprot.writeFieldBegin("containers", TType.LIST, 8)
            oprot.writeListBegin(TType.STRUCT, len(self.containers))
            for iter175 in self.containers:
                iter175.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.id)
        value = (value * 31) ^ hash(self.repositoryURL)
        value = (value * 31) ^ hash(self.file)
        value = (value * 31) ^ hash(self.metamodelUri)
        value = (value * 31) ^ hash(self.typeName)
        value = (value * 31) ^ hash(self.attributes)
        value = (value * 31) ^ hash(self.references)
        value = (value * 31) ^ hash(self.containers)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ContainerSlot:
    """
  Attributes:
   - name
   - elements
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "name", None, None,),  # 1
        (
            2,
            TType.LIST,
            "elements",
            (TType.STRUCT, (ModelElement, ModelElement.thrift_spec)),
            None,
        ),  # 2
    )

    def __init__(
        self, name=None, elements=None,
    ):
        self.name = name
        self.elements = elements

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.elements = []
                    (_etype179, _size176) = iprot.readListBegin()
                    for _i180 in range(_size176):
                        _elem181 = ModelElement()
                        _elem181.read(iprot)
                        self.elements.append(_elem181)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("ContainerSlot")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        if self.elements is not None:
            oprot.writeFieldBegin("elements", TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.elements))
            for iter182 in self.elements:
                iter182.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocol.TProtocolException(message="Required field name is unset!")
        if self.elements is None:
            raise TProtocol.TProtocolException(
                message="Required field elements is unset!"
            )
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.name)
        value = (value * 31) ^ hash(self.elements)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class QueryResult:
    """
  Attributes:
   - vBoolean
   - vByte
   - vShort
   - vInteger
   - vLong
   - vDouble
   - vString
   - vModelElement
   - vModelElementType
   - vMap
   - vList
  """

    thrift_spec = (
        None,  # 0
        (1, TType.BOOL, "vBoolean", None, None,),  # 1
        (2, TType.BYTE, "vByte", None, None,),  # 2
        (3, TType.I16, "vShort", None, None,),  # 3
        (4, TType.I32, "vInteger", None, None,),  # 4
        (5, TType.I64, "vLong", None, None,),  # 5
        (6, TType.DOUBLE, "vDouble", None, None,),  # 6
        (7, TType.STRING, "vString", None, None,),  # 7
        (
            8,
            TType.STRUCT,
            "vModelElement",
            (ModelElement, ModelElement.thrift_spec),
            None,
        ),  # 8
        (
            9,
            TType.STRUCT,
            "vModelElementType",
            (ModelElementType, ModelElementType.thrift_spec),
            None,
        ),  # 9
        (
            10,
            TType.MAP,
            "vMap",
            (TType.STRING, None, TType.STRUCT, ('QueryResult', 'QueryResult.thrift_spec')),
            None,
        ),  # 10
        (
            11,
            TType.LIST,
            "vList",
            (TType.STRUCT, ('QueryResult', 'QueryResult.thrift_spec')),
            None,
        ),  # 11
    )

    def __init__(
        self,
        vBoolean=None,
        vByte=None,
        vShort=None,
        vInteger=None,
        vLong=None,
        vDouble=None,
        vString=None,
        vModelElement=None,
        vModelElementType=None,
        vMap=None,
        vList=None,
    ):
        self.vBoolean = vBoolean
        self.vByte = vByte
        self.vShort = vShort
        self.vInteger = vInteger
        self.vLong = vLong
        self.vDouble = vDouble
        self.vString = vString
        self.vModelElement = vModelElement
        self.vModelElementType = vModelElementType
        self.vMap = vMap
        self.vList = vList

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.vBoolean = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.vByte = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.vShort = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.vInteger = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.vLong = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.DOUBLE:
                    self.vDouble = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.vString = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.vModelElement = ModelElement()
                    self.vModelElement.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRUCT:
                    self.vModelElementType = ModelElementType()
                    self.vModelElementType.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.MAP:
                    self.vMap = {}
                    (_ktype184, _vtype185, _size183) = iprot.readMapBegin()
                    for _i187 in range(_size183):
                        _key188 = iprot.readString()
                        _val189 = QueryResult()
                        _val189.read(iprot)
                        self.vMap[_key188] = _val189
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.LIST:
                    self.vList = []
                    (_etype193, _size190) = iprot.readListBegin()
                    for _i194 in range(_size190):
                        _elem195 = QueryResult()
                        _elem195.read(iprot)
                        self.vList.append(_elem195)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("QueryResult")
        if self.vBoolean is not None:
            oprot.writeFieldBegin("vBoolean", TType.BOOL, 1)
            oprot.writeBool(self.vBoolean)
            oprot.writeFieldEnd()
        if self.vByte is not None:
            oprot.writeFieldBegin("vByte", TType.BYTE, 2)
            oprot.writeByte(self.vByte)
            oprot.writeFieldEnd()
        if self.vShort is not None:
            oprot.writeFieldBegin("vShort", TType.I16, 3)
            oprot.writeI16(self.vShort)
            oprot.writeFieldEnd()
        if self.vInteger is not None:
            oprot.writeFieldBegin("vInteger", TType.I32, 4)
            oprot.writeI32(self.vInteger)
            oprot.writeFieldEnd()
        if self.vLong is not None:
            oprot.writeFieldBegin("vLong", TType.I64, 5)
            oprot.writeI64(self.vLong)
            oprot.writeFieldEnd()
        if self.vDouble is not None:
            oprot.writeFieldBegin("vDouble", TType.DOUBLE, 6)
            oprot.writeDouble(self.vDouble)
            oprot.writeFieldEnd()
        if self.vString is not None:
            oprot.writeFieldBegin("vString", TType.STRING, 7)
            oprot.writeString(self.vString)
            oprot.writeFieldEnd()
        if self.vModelElement is not None:
            oprot.writeFieldBegin("vModelElement", TType.STRUCT, 8)
            self.vModelElement.write(oprot)
            oprot.writeFieldEnd()
        if self.vModelElementType is not None:
            oprot.writeFieldBegin("vModelElementType", TType.STRUCT, 9)
            self.vModelElementType.write(oprot)
            oprot.writeFieldEnd()
        if self.vMap is not None:
            oprot.writeFieldBegin("vMap", TType.MAP, 10)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.vMap))
            for kiter196, viter197 in list(self.vMap.items()):
                oprot.writeString(kiter196)
                viter197.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.vList is not None:
            oprot.writeFieldBegin("vList", TType.LIST, 11)
            oprot.writeListBegin(TType.STRUCT, len(self.vList))
            for iter198 in self.vList:
                iter198.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.vBoolean)
        value = (value * 31) ^ hash(self.vByte)
        value = (value * 31) ^ hash(self.vShort)
        value = (value * 31) ^ hash(self.vInteger)
        value = (value * 31) ^ hash(self.vLong)
        value = (value * 31) ^ hash(self.vDouble)
        value = (value * 31) ^ hash(self.vString)
        value = (value * 31) ^ hash(self.vModelElement)
        value = (value * 31) ^ hash(self.vModelElementType)
        value = (value * 31) ^ hash(self.vMap)
        value = (value * 31) ^ hash(self.vList)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class QueryReport:
    """
  Attributes:
   - result
   - wallMillis
   - isCancelled
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, "result", (QueryResult, QueryResult.thrift_spec), None,),  # 1
        (2, TType.I64, "wallMillis", None, None,),  # 2
        (3, TType.BOOL, "isCancelled", None, None,),  # 3
    )

    def __init__(
        self, result=None, wallMillis=None, isCancelled=None,
    ):
        self.result = result
        self.wallMillis = wallMillis
        self.isCancelled = isCancelled

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.result = QueryResult()
                    self.result.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.wallMillis = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.isCancelled = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("QueryReport")
        if self.result is not None:
            oprot.writeFieldBegin("result", TType.STRUCT, 1)
            self.result.write(oprot)
            oprot.writeFieldEnd()
        if self.wallMillis is not None:
            oprot.writeFieldBegin("wallMillis", TType.I64, 2)
            oprot.writeI64(self.wallMillis)
            oprot.writeFieldEnd()
        if self.isCancelled is not None:
            oprot.writeFieldBegin("isCancelled", TType.BOOL, 3)
            oprot.writeBool(self.isCancelled)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.result is None:
            raise TProtocol.TProtocolException(
                message="Required field result is unset!"
            )
        if self.wallMillis is None:
            raise TProtocol.TProtocolException(
                message="Required field wallMillis is unset!"
            )
        if self.isCancelled is None:
            raise TProtocol.TProtocolException(
                message="Required field isCancelled is unset!"
            )
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.result)
        value = (value * 31) ^ hash(self.wallMillis)
        value = (value * 31) ^ hash(self.isCancelled)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
