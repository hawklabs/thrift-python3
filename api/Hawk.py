#
# Autogenerated by Thrift Compiler (0.9.3)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol

try:
    from thrift.protocol import fastbinary
except:
    fastbinary = None


class Iface:
    def createInstance(
        self,
        name,
        backend,
        minimumDelayMillis,
        maximumDelayMillis,
        enabledPlugins,
        indexFactory,
    ):
        """
    Parameters:
     - name
     - backend
     - minimumDelayMillis
     - maximumDelayMillis
     - enabledPlugins
     - indexFactory
    """
        pass

    def listBackends(self):
        pass

    def listPlugins(self):
        pass

    def listPluginDetails(self):
        pass

    def listInstances(self):
        pass

    def removeInstance(self, name):
        """
    Parameters:
     - name
    """
        pass

    def startInstance(self, name):
        """
    Parameters:
     - name
    """
        pass

    def stopInstance(self, name):
        """
    Parameters:
     - name
    """
        pass

    def syncInstance(self, name, blockUntilDone):
        """
    Parameters:
     - name
     - blockUntilDone
    """
        pass

    def registerMetamodels(self, name, metamodel):
        """
    Parameters:
     - name
     - metamodel
    """
        pass

    def unregisterMetamodels(self, name, metamodel):
        """
    Parameters:
     - name
     - metamodel
    """
        pass

    def listMetamodels(self, name):
        """
    Parameters:
     - name
    """
        pass

    def listTypeNames(self, hawkInstanceName, metamodelURI):
        """
    Parameters:
     - hawkInstanceName
     - metamodelURI
    """
        pass

    def listAttributeNames(self, hawkInstanceName, metamodelURI, typeName):
        """
    Parameters:
     - hawkInstanceName
     - metamodelURI
     - typeName
    """
        pass

    def listMetamodelParsers(self, name):
        """
    Parameters:
     - name
    """
        pass

    def listQueryLanguages(self, name):
        """
    Parameters:
     - name
    """
        pass

    def query(self, name, query, language, options):
        """
    Parameters:
     - name
     - query
     - language
     - options
    """
        pass

    def timedQuery(self, name, query, language, options):
        """
    Parameters:
     - name
     - query
     - language
     - options
    """
        pass

    def resolveProxies(self, name, ids, options):
        """
    Parameters:
     - name
     - ids
     - options
    """
        pass

    def asyncQuery(self, name, query, language, options):
        """
    Parameters:
     - name
     - query
     - language
     - options
    """
        pass

    def cancelAsyncQuery(self, queryID):
        """
    Parameters:
     - queryID
    """
        pass

    def fetchAsyncQueryResults(self, queryID):
        """
    Parameters:
     - queryID
    """
        pass

    def addRepository(self, name, repo, credentials):
        """
    Parameters:
     - name
     - repo
     - credentials
    """
        pass

    def isFrozen(self, name, uri):
        """
    Parameters:
     - name
     - uri
    """
        pass

    def setFrozen(self, name, uri, isFrozen):
        """
    Parameters:
     - name
     - uri
     - isFrozen
    """
        pass

    def removeRepository(self, name, uri):
        """
    Parameters:
     - name
     - uri
    """
        pass

    def updateRepositoryCredentials(self, name, uri, cred):
        """
    Parameters:
     - name
     - uri
     - cred
    """
        pass

    def listRepositories(self, name):
        """
    Parameters:
     - name
    """
        pass

    def listRepositoryTypes(self):
        pass

    def listFiles(self, name, repository, filePatterns):
        """
    Parameters:
     - name
     - repository
     - filePatterns
    """
        pass

    def configurePolling(self, name, base, max):
        """
    Parameters:
     - name
     - base
     - max
    """
        pass

    def addDerivedAttribute(self, name, spec):
        """
    Parameters:
     - name
     - spec
    """
        pass

    def removeDerivedAttribute(self, name, spec):
        """
    Parameters:
     - name
     - spec
    """
        pass

    def listDerivedAttributes(self, name):
        """
    Parameters:
     - name
    """
        pass

    def addIndexedAttribute(self, name, spec):
        """
    Parameters:
     - name
     - spec
    """
        pass

    def removeIndexedAttribute(self, name, spec):
        """
    Parameters:
     - name
     - spec
    """
        pass

    def listIndexedAttributes(self, name):
        """
    Parameters:
     - name
    """
        pass

    def getModel(self, name, options):
        """
    Parameters:
     - name
     - options
    """
        pass

    def getRootElements(self, name, options):
        """
    Parameters:
     - name
     - options
    """
        pass

    def watchStateChanges(self, name):
        """
    Parameters:
     - name
    """
        pass

    def watchModelChanges(self, name, repositoryUri, filePath, clientID, durableEvents):
        """
    Parameters:
     - name
     - repositoryUri
     - filePath
     - clientID
     - durableEvents
    """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def createInstance(
        self,
        name,
        backend,
        minimumDelayMillis,
        maximumDelayMillis,
        enabledPlugins,
        indexFactory,
    ):
        """
    Parameters:
     - name
     - backend
     - minimumDelayMillis
     - maximumDelayMillis
     - enabledPlugins
     - indexFactory
    """
        self.send_createInstance(
            name,
            backend,
            minimumDelayMillis,
            maximumDelayMillis,
            enabledPlugins,
            indexFactory,
        )
        self.recv_createInstance()

    def send_createInstance(
        self,
        name,
        backend,
        minimumDelayMillis,
        maximumDelayMillis,
        enabledPlugins,
        indexFactory,
    ):
        self._oprot.writeMessageBegin("createInstance", TMessageType.CALL, self._seqid)
        args = createInstance_args()
        args.name = name
        args.backend = backend
        args.minimumDelayMillis = minimumDelayMillis
        args.maximumDelayMillis = maximumDelayMillis
        args.enabledPlugins = enabledPlugins
        args.indexFactory = indexFactory
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createInstance(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createInstance_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.err1 is not None:
            raise result.err1
        return

    def listBackends(self):
        self.send_listBackends()
        return self.recv_listBackends()

    def send_listBackends(self):
        self._oprot.writeMessageBegin("listBackends", TMessageType.CALL, self._seqid)
        args = listBackends_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_listBackends(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = listBackends_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "listBackends failed: unknown result"
        )

    def listPlugins(self):
        self.send_listPlugins()
        return self.recv_listPlugins()

    def send_listPlugins(self):
        self._oprot.writeMessageBegin("listPlugins", TMessageType.CALL, self._seqid)
        args = listPlugins_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_listPlugins(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = listPlugins_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "listPlugins failed: unknown result"
        )

    def listPluginDetails(self):
        self.send_listPluginDetails()
        return self.recv_listPluginDetails()

    def send_listPluginDetails(self):
        self._oprot.writeMessageBegin(
            "listPluginDetails", TMessageType.CALL, self._seqid
        )
        args = listPluginDetails_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_listPluginDetails(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = listPluginDetails_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "listPluginDetails failed: unknown result",
        )

    def listInstances(self):
        self.send_listInstances()
        return self.recv_listInstances()

    def send_listInstances(self):
        self._oprot.writeMessageBegin("listInstances", TMessageType.CALL, self._seqid)
        args = listInstances_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_listInstances(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = listInstances_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "listInstances failed: unknown result"
        )

    def removeInstance(self, name):
        """
    Parameters:
     - name
    """
        self.send_removeInstance(name)
        self.recv_removeInstance()

    def send_removeInstance(self, name):
        self._oprot.writeMessageBegin("removeInstance", TMessageType.CALL, self._seqid)
        args = removeInstance_args()
        args.name = name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_removeInstance(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = removeInstance_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.err1 is not None:
            raise result.err1
        return

    def startInstance(self, name):
        """
    Parameters:
     - name
    """
        self.send_startInstance(name)
        self.recv_startInstance()

    def send_startInstance(self, name):
        self._oprot.writeMessageBegin("startInstance", TMessageType.CALL, self._seqid)
        args = startInstance_args()
        args.name = name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_startInstance(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = startInstance_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.err1 is not None:
            raise result.err1
        return

    def stopInstance(self, name):
        """
    Parameters:
     - name
    """
        self.send_stopInstance(name)
        self.recv_stopInstance()

    def send_stopInstance(self, name):
        self._oprot.writeMessageBegin("stopInstance", TMessageType.CALL, self._seqid)
        args = stopInstance_args()
        args.name = name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_stopInstance(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = stopInstance_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.err1 is not None:
            raise result.err1
        if result.err2 is not None:
            raise result.err2
        return

    def syncInstance(self, name, blockUntilDone):
        """
    Parameters:
     - name
     - blockUntilDone
    """
        self.send_syncInstance(name, blockUntilDone)
        self.recv_syncInstance()

    def send_syncInstance(self, name, blockUntilDone):
        self._oprot.writeMessageBegin("syncInstance", TMessageType.CALL, self._seqid)
        args = syncInstance_args()
        args.name = name
        args.blockUntilDone = blockUntilDone
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_syncInstance(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = syncInstance_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.err1 is not None:
            raise result.err1
        if result.err2 is not None:
            raise result.err2
        return

    def registerMetamodels(self, name, metamodel):
        """
    Parameters:
     - name
     - metamodel
    """
        self.send_registerMetamodels(name, metamodel)
        self.recv_registerMetamodels()

    def send_registerMetamodels(self, name, metamodel):
        self._oprot.writeMessageBegin(
            "registerMetamodels", TMessageType.CALL, self._seqid
        )
        args = registerMetamodels_args()
        args.name = name
        args.metamodel = metamodel
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_registerMetamodels(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = registerMetamodels_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.err1 is not None:
            raise result.err1
        if result.err2 is not None:
            raise result.err2
        if result.err3 is not None:
            raise result.err3
        return

    def unregisterMetamodels(self, name, metamodel):
        """
    Parameters:
     - name
     - metamodel
    """
        self.send_unregisterMetamodels(name, metamodel)
        self.recv_unregisterMetamodels()

    def send_unregisterMetamodels(self, name, metamodel):
        self._oprot.writeMessageBegin(
            "unregisterMetamodels", TMessageType.CALL, self._seqid
        )
        args = unregisterMetamodels_args()
        args.name = name
        args.metamodel = metamodel
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_unregisterMetamodels(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = unregisterMetamodels_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.err1 is not None:
            raise result.err1
        if result.err2 is not None:
            raise result.err2
        return

    def listMetamodels(self, name):
        """
    Parameters:
     - name
    """
        self.send_listMetamodels(name)
        return self.recv_listMetamodels()

    def send_listMetamodels(self, name):
        self._oprot.writeMessageBegin("listMetamodels", TMessageType.CALL, self._seqid)
        args = listMetamodels_args()
        args.name = name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_listMetamodels(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = listMetamodels_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.err1 is not None:
            raise result.err1
        if result.err2 is not None:
            raise result.err2
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "listMetamodels failed: unknown result",
        )

    def listTypeNames(self, hawkInstanceName, metamodelURI):
        """
    Parameters:
     - hawkInstanceName
     - metamodelURI
    """
        self.send_listTypeNames(hawkInstanceName, metamodelURI)
        return self.recv_listTypeNames()

    def send_listTypeNames(self, hawkInstanceName, metamodelURI):
        self._oprot.writeMessageBegin("listTypeNames", TMessageType.CALL, self._seqid)
        args = listTypeNames_args()
        args.hawkInstanceName = hawkInstanceName
        args.metamodelURI = metamodelURI
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_listTypeNames(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = listTypeNames_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.err1 is not None:
            raise result.err1
        if result.err2 is not None:
            raise result.err2
        if result.err3 is not None:
            raise result.err3
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "listTypeNames failed: unknown result"
        )

    def listAttributeNames(self, hawkInstanceName, metamodelURI, typeName):
        """
    Parameters:
     - hawkInstanceName
     - metamodelURI
     - typeName
    """
        self.send_listAttributeNames(hawkInstanceName, metamodelURI, typeName)
        return self.recv_listAttributeNames()

    def send_listAttributeNames(self, hawkInstanceName, metamodelURI, typeName):
        self._oprot.writeMessageBegin(
            "listAttributeNames", TMessageType.CALL, self._seqid
        )
        args = listAttributeNames_args()
        args.hawkInstanceName = hawkInstanceName
        args.metamodelURI = metamodelURI
        args.typeName = typeName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_listAttributeNames(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = listAttributeNames_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.err1 is not None:
            raise result.err1
        if result.err2 is not None:
            raise result.err2
        if result.err3 is not None:
            raise result.err3
        if result.err4 is not None:
            raise result.err4
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "listAttributeNames failed: unknown result",
        )

    def listMetamodelParsers(self, name):
        """
    Parameters:
     - name
    """
        self.send_listMetamodelParsers(name)
        return self.recv_listMetamodelParsers()

    def send_listMetamodelParsers(self, name):
        self._oprot.writeMessageBegin(
            "listMetamodelParsers", TMessageType.CALL, self._seqid
        )
        args = listMetamodelParsers_args()
        args.name = name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_listMetamodelParsers(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = listMetamodelParsers_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.err1 is not None:
            raise result.err1
        if result.err2 is not None:
            raise result.err2
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "listMetamodelParsers failed: unknown result",
        )

    def listQueryLanguages(self, name):
        """
    Parameters:
     - name
    """
        self.send_listQueryLanguages(name)
        return self.recv_listQueryLanguages()

    def send_listQueryLanguages(self, name):
        self._oprot.writeMessageBegin(
            "listQueryLanguages", TMessageType.CALL, self._seqid
        )
        args = listQueryLanguages_args()
        args.name = name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_listQueryLanguages(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = listQueryLanguages_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "listQueryLanguages failed: unknown result",
        )

    def query(self, name, query, language, options):
        """
    Parameters:
     - name
     - query
     - language
     - options
    """
        self.send_query(name, query, language, options)
        return self.recv_query()

    def send_query(self, name, query, language, options):
        self._oprot.writeMessageBegin("query", TMessageType.CALL, self._seqid)
        args = query_args()
        args.name = name
        args.query = query
        args.language = language
        args.options = options
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.err1 is not None:
            raise result.err1
        if result.err2 is not None:
            raise result.err2
        if result.err3 is not None:
            raise result.err3
        if result.err4 is not None:
            raise result.err4
        if result.err5 is not None:
            raise result.err5
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "query failed: unknown result"
        )

    def timedQuery(self, name, query, language, options):
        """
    Parameters:
     - name
     - query
     - language
     - options
    """
        self.send_timedQuery(name, query, language, options)
        return self.recv_timedQuery()

    def send_timedQuery(self, name, query, language, options):
        self._oprot.writeMessageBegin("timedQuery", TMessageType.CALL, self._seqid)
        args = timedQuery_args()
        args.name = name
        args.query = query
        args.language = language
        args.options = options
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_timedQuery(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = timedQuery_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.err1 is not None:
            raise result.err1
        if result.err2 is not None:
            raise result.err2
        if result.err3 is not None:
            raise result.err3
        if result.err4 is not None:
            raise result.err4
        if result.err5 is not None:
            raise result.err5
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "timedQuery failed: unknown result"
        )

    def resolveProxies(self, name, ids, options):
        """
    Parameters:
     - name
     - ids
     - options
    """
        self.send_resolveProxies(name, ids, options)
        return self.recv_resolveProxies()

    def send_resolveProxies(self, name, ids, options):
        self._oprot.writeMessageBegin("resolveProxies", TMessageType.CALL, self._seqid)
        args = resolveProxies_args()
        args.name = name
        args.ids = ids
        args.options = options
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_resolveProxies(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = resolveProxies_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.err1 is not None:
            raise result.err1
        if result.err2 is not None:
            raise result.err2
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "resolveProxies failed: unknown result",
        )

    def asyncQuery(self, name, query, language, options):
        """
    Parameters:
     - name
     - query
     - language
     - options
    """
        self.send_asyncQuery(name, query, language, options)
        return self.recv_asyncQuery()

    def send_asyncQuery(self, name, query, language, options):
        self._oprot.writeMessageBegin("asyncQuery", TMessageType.CALL, self._seqid)
        args = asyncQuery_args()
        args.name = name
        args.query = query
        args.language = language
        args.options = options
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_asyncQuery(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = asyncQuery_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.err1 is not None:
            raise result.err1
        if result.err2 is not None:
            raise result.err2
        if result.err3 is not None:
            raise result.err3
        if result.err4 is not None:
            raise result.err4
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "asyncQuery failed: unknown result"
        )

    def cancelAsyncQuery(self, queryID):
        """
    Parameters:
     - queryID
    """
        self.send_cancelAsyncQuery(queryID)
        self.recv_cancelAsyncQuery()

    def send_cancelAsyncQuery(self, queryID):
        self._oprot.writeMessageBegin(
            "cancelAsyncQuery", TMessageType.CALL, self._seqid
        )
        args = cancelAsyncQuery_args()
        args.queryID = queryID
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_cancelAsyncQuery(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = cancelAsyncQuery_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.err1 is not None:
            raise result.err1
        return

    def fetchAsyncQueryResults(self, queryID):
        """
    Parameters:
     - queryID
    """
        self.send_fetchAsyncQueryResults(queryID)
        return self.recv_fetchAsyncQueryResults()

    def send_fetchAsyncQueryResults(self, queryID):
        self._oprot.writeMessageBegin(
            "fetchAsyncQueryResults", TMessageType.CALL, self._seqid
        )
        args = fetchAsyncQueryResults_args()
        args.queryID = queryID
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fetchAsyncQueryResults(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fetchAsyncQueryResults_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.err1 is not None:
            raise result.err1
        if result.err2 is not None:
            raise result.err2
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "fetchAsyncQueryResults failed: unknown result",
        )

    def addRepository(self, name, repo, credentials):
        """
    Parameters:
     - name
     - repo
     - credentials
    """
        self.send_addRepository(name, repo, credentials)
        self.recv_addRepository()

    def send_addRepository(self, name, repo, credentials):
        self._oprot.writeMessageBegin("addRepository", TMessageType.CALL, self._seqid)
        args = addRepository_args()
        args.name = name
        args.repo = repo
        args.credentials = credentials
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_addRepository(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = addRepository_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.err1 is not None:
            raise result.err1
        if result.err2 is not None:
            raise result.err2
        if result.err3 is not None:
            raise result.err3
        if result.err4 is not None:
            raise result.err4
        return

    def isFrozen(self, name, uri):
        """
    Parameters:
     - name
     - uri
    """
        self.send_isFrozen(name, uri)
        return self.recv_isFrozen()

    def send_isFrozen(self, name, uri):
        self._oprot.writeMessageBegin("isFrozen", TMessageType.CALL, self._seqid)
        args = isFrozen_args()
        args.name = name
        args.uri = uri
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_isFrozen(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = isFrozen_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.err1 is not None:
            raise result.err1
        if result.err2 is not None:
            raise result.err2
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "isFrozen failed: unknown result"
        )

    def setFrozen(self, name, uri, isFrozen):
        """
    Parameters:
     - name
     - uri
     - isFrozen
    """
        self.send_setFrozen(name, uri, isFrozen)
        self.recv_setFrozen()

    def send_setFrozen(self, name, uri, isFrozen):
        self._oprot.writeMessageBegin("setFrozen", TMessageType.CALL, self._seqid)
        args = setFrozen_args()
        args.name = name
        args.uri = uri
        args.isFrozen = isFrozen
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_setFrozen(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = setFrozen_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.err1 is not None:
            raise result.err1
        if result.err2 is not None:
            raise result.err2
        return

    def removeRepository(self, name, uri):
        """
    Parameters:
     - name
     - uri
    """
        self.send_removeRepository(name, uri)
        self.recv_removeRepository()

    def send_removeRepository(self, name, uri):
        self._oprot.writeMessageBegin(
            "removeRepository", TMessageType.CALL, self._seqid
        )
        args = removeRepository_args()
        args.name = name
        args.uri = uri
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_removeRepository(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = removeRepository_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.err1 is not None:
            raise result.err1
        if result.err2 is not None:
            raise result.err2
        return

    def updateRepositoryCredentials(self, name, uri, cred):
        """
    Parameters:
     - name
     - uri
     - cred
    """
        self.send_updateRepositoryCredentials(name, uri, cred)
        self.recv_updateRepositoryCredentials()

    def send_updateRepositoryCredentials(self, name, uri, cred):
        self._oprot.writeMessageBegin(
            "updateRepositoryCredentials", TMessageType.CALL, self._seqid
        )
        args = updateRepositoryCredentials_args()
        args.name = name
        args.uri = uri
        args.cred = cred
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updateRepositoryCredentials(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updateRepositoryCredentials_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.err1 is not None:
            raise result.err1
        if result.err2 is not None:
            raise result.err2
        return

    def listRepositories(self, name):
        """
    Parameters:
     - name
    """
        self.send_listRepositories(name)
        return self.recv_listRepositories()

    def send_listRepositories(self, name):
        self._oprot.writeMessageBegin(
            "listRepositories", TMessageType.CALL, self._seqid
        )
        args = listRepositories_args()
        args.name = name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_listRepositories(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = listRepositories_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.err1 is not None:
            raise result.err1
        if result.err2 is not None:
            raise result.err2
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "listRepositories failed: unknown result",
        )

    def listRepositoryTypes(self):
        self.send_listRepositoryTypes()
        return self.recv_listRepositoryTypes()

    def send_listRepositoryTypes(self):
        self._oprot.writeMessageBegin(
            "listRepositoryTypes", TMessageType.CALL, self._seqid
        )
        args = listRepositoryTypes_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_listRepositoryTypes(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = listRepositoryTypes_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "listRepositoryTypes failed: unknown result",
        )

    def listFiles(self, name, repository, filePatterns):
        """
    Parameters:
     - name
     - repository
     - filePatterns
    """
        self.send_listFiles(name, repository, filePatterns)
        return self.recv_listFiles()

    def send_listFiles(self, name, repository, filePatterns):
        self._oprot.writeMessageBegin("listFiles", TMessageType.CALL, self._seqid)
        args = listFiles_args()
        args.name = name
        args.repository = repository
        args.filePatterns = filePatterns
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_listFiles(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = listFiles_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.err1 is not None:
            raise result.err1
        if result.err2 is not None:
            raise result.err2
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "listFiles failed: unknown result"
        )

    def configurePolling(self, name, base, max):
        """
    Parameters:
     - name
     - base
     - max
    """
        self.send_configurePolling(name, base, max)
        self.recv_configurePolling()

    def send_configurePolling(self, name, base, max):
        self._oprot.writeMessageBegin(
            "configurePolling", TMessageType.CALL, self._seqid
        )
        args = configurePolling_args()
        args.name = name
        args.base = base
        args.max = max
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_configurePolling(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = configurePolling_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.err1 is not None:
            raise result.err1
        if result.err2 is not None:
            raise result.err2
        if result.err3 is not None:
            raise result.err3
        return

    def addDerivedAttribute(self, name, spec):
        """
    Parameters:
     - name
     - spec
    """
        self.send_addDerivedAttribute(name, spec)
        self.recv_addDerivedAttribute()

    def send_addDerivedAttribute(self, name, spec):
        self._oprot.writeMessageBegin(
            "addDerivedAttribute", TMessageType.CALL, self._seqid
        )
        args = addDerivedAttribute_args()
        args.name = name
        args.spec = spec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_addDerivedAttribute(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = addDerivedAttribute_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.err1 is not None:
            raise result.err1
        if result.err2 is not None:
            raise result.err2
        if result.err3 is not None:
            raise result.err3
        return

    def removeDerivedAttribute(self, name, spec):
        """
    Parameters:
     - name
     - spec
    """
        self.send_removeDerivedAttribute(name, spec)
        self.recv_removeDerivedAttribute()

    def send_removeDerivedAttribute(self, name, spec):
        self._oprot.writeMessageBegin(
            "removeDerivedAttribute", TMessageType.CALL, self._seqid
        )
        args = removeDerivedAttribute_args()
        args.name = name
        args.spec = spec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_removeDerivedAttribute(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = removeDerivedAttribute_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.err1 is not None:
            raise result.err1
        if result.err2 is not None:
            raise result.err2
        return

    def listDerivedAttributes(self, name):
        """
    Parameters:
     - name
    """
        self.send_listDerivedAttributes(name)
        return self.recv_listDerivedAttributes()

    def send_listDerivedAttributes(self, name):
        self._oprot.writeMessageBegin(
            "listDerivedAttributes", TMessageType.CALL, self._seqid
        )
        args = listDerivedAttributes_args()
        args.name = name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_listDerivedAttributes(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = listDerivedAttributes_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.err1 is not None:
            raise result.err1
        if result.err2 is not None:
            raise result.err2
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "listDerivedAttributes failed: unknown result",
        )

    def addIndexedAttribute(self, name, spec):
        """
    Parameters:
     - name
     - spec
    """
        self.send_addIndexedAttribute(name, spec)
        self.recv_addIndexedAttribute()

    def send_addIndexedAttribute(self, name, spec):
        self._oprot.writeMessageBegin(
            "addIndexedAttribute", TMessageType.CALL, self._seqid
        )
        args = addIndexedAttribute_args()
        args.name = name
        args.spec = spec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_addIndexedAttribute(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = addIndexedAttribute_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.err1 is not None:
            raise result.err1
        if result.err2 is not None:
            raise result.err2
        if result.err3 is not None:
            raise result.err3
        return

    def removeIndexedAttribute(self, name, spec):
        """
    Parameters:
     - name
     - spec
    """
        self.send_removeIndexedAttribute(name, spec)
        self.recv_removeIndexedAttribute()

    def send_removeIndexedAttribute(self, name, spec):
        self._oprot.writeMessageBegin(
            "removeIndexedAttribute", TMessageType.CALL, self._seqid
        )
        args = removeIndexedAttribute_args()
        args.name = name
        args.spec = spec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_removeIndexedAttribute(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = removeIndexedAttribute_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.err1 is not None:
            raise result.err1
        if result.err2 is not None:
            raise result.err2
        return

    def listIndexedAttributes(self, name):
        """
    Parameters:
     - name
    """
        self.send_listIndexedAttributes(name)
        return self.recv_listIndexedAttributes()

    def send_listIndexedAttributes(self, name):
        self._oprot.writeMessageBegin(
            "listIndexedAttributes", TMessageType.CALL, self._seqid
        )
        args = listIndexedAttributes_args()
        args.name = name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_listIndexedAttributes(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = listIndexedAttributes_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.err1 is not None:
            raise result.err1
        if result.err2 is not None:
            raise result.err2
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "listIndexedAttributes failed: unknown result",
        )

    def getModel(self, name, options):
        """
    Parameters:
     - name
     - options
    """
        self.send_getModel(name, options)
        return self.recv_getModel()

    def send_getModel(self, name, options):
        self._oprot.writeMessageBegin("getModel", TMessageType.CALL, self._seqid)
        args = getModel_args()
        args.name = name
        args.options = options
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getModel(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getModel_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.err1 is not None:
            raise result.err1
        if result.err2 is not None:
            raise result.err2
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "getModel failed: unknown result"
        )

    def getRootElements(self, name, options):
        """
    Parameters:
     - name
     - options
    """
        self.send_getRootElements(name, options)
        return self.recv_getRootElements()

    def send_getRootElements(self, name, options):
        self._oprot.writeMessageBegin("getRootElements", TMessageType.CALL, self._seqid)
        args = getRootElements_args()
        args.name = name
        args.options = options
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getRootElements(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getRootElements_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "getRootElements failed: unknown result",
        )

    def watchStateChanges(self, name):
        """
    Parameters:
     - name
    """
        self.send_watchStateChanges(name)
        return self.recv_watchStateChanges()

    def send_watchStateChanges(self, name):
        self._oprot.writeMessageBegin(
            "watchStateChanges", TMessageType.CALL, self._seqid
        )
        args = watchStateChanges_args()
        args.name = name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_watchStateChanges(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = watchStateChanges_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.err1 is not None:
            raise result.err1
        if result.err2 is not None:
            raise result.err2
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "watchStateChanges failed: unknown result",
        )

    def watchModelChanges(self, name, repositoryUri, filePath, clientID, durableEvents):
        """
    Parameters:
     - name
     - repositoryUri
     - filePath
     - clientID
     - durableEvents
    """
        self.send_watchModelChanges(
            name, repositoryUri, filePath, clientID, durableEvents
        )
        return self.recv_watchModelChanges()

    def send_watchModelChanges(
        self, name, repositoryUri, filePath, clientID, durableEvents
    ):
        self._oprot.writeMessageBegin(
            "watchModelChanges", TMessageType.CALL, self._seqid
        )
        args = watchModelChanges_args()
        args.name = name
        args.repositoryUri = repositoryUri
        args.filePath = filePath
        args.clientID = clientID
        args.durableEvents = durableEvents
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_watchModelChanges(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = watchModelChanges_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.err1 is not None:
            raise result.err1
        if result.err2 is not None:
            raise result.err2
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "watchModelChanges failed: unknown result",
        )


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["createInstance"] = Processor.process_createInstance
        self._processMap["listBackends"] = Processor.process_listBackends
        self._processMap["listPlugins"] = Processor.process_listPlugins
        self._processMap["listPluginDetails"] = Processor.process_listPluginDetails
        self._processMap["listInstances"] = Processor.process_listInstances
        self._processMap["removeInstance"] = Processor.process_removeInstance
        self._processMap["startInstance"] = Processor.process_startInstance
        self._processMap["stopInstance"] = Processor.process_stopInstance
        self._processMap["syncInstance"] = Processor.process_syncInstance
        self._processMap["registerMetamodels"] = Processor.process_registerMetamodels
        self._processMap[
            "unregisterMetamodels"
        ] = Processor.process_unregisterMetamodels
        self._processMap["listMetamodels"] = Processor.process_listMetamodels
        self._processMap["listTypeNames"] = Processor.process_listTypeNames
        self._processMap["listAttributeNames"] = Processor.process_listAttributeNames
        self._processMap[
            "listMetamodelParsers"
        ] = Processor.process_listMetamodelParsers
        self._processMap["listQueryLanguages"] = Processor.process_listQueryLanguages
        self._processMap["query"] = Processor.process_query
        self._processMap["timedQuery"] = Processor.process_timedQuery
        self._processMap["resolveProxies"] = Processor.process_resolveProxies
        self._processMap["asyncQuery"] = Processor.process_asyncQuery
        self._processMap["cancelAsyncQuery"] = Processor.process_cancelAsyncQuery
        self._processMap[
            "fetchAsyncQueryResults"
        ] = Processor.process_fetchAsyncQueryResults
        self._processMap["addRepository"] = Processor.process_addRepository
        self._processMap["isFrozen"] = Processor.process_isFrozen
        self._processMap["setFrozen"] = Processor.process_setFrozen
        self._processMap["removeRepository"] = Processor.process_removeRepository
        self._processMap[
            "updateRepositoryCredentials"
        ] = Processor.process_updateRepositoryCredentials
        self._processMap["listRepositories"] = Processor.process_listRepositories
        self._processMap["listRepositoryTypes"] = Processor.process_listRepositoryTypes
        self._processMap["listFiles"] = Processor.process_listFiles
        self._processMap["configurePolling"] = Processor.process_configurePolling
        self._processMap["addDerivedAttribute"] = Processor.process_addDerivedAttribute
        self._processMap[
            "removeDerivedAttribute"
        ] = Processor.process_removeDerivedAttribute
        self._processMap[
            "listDerivedAttributes"
        ] = Processor.process_listDerivedAttributes
        self._processMap["addIndexedAttribute"] = Processor.process_addIndexedAttribute
        self._processMap[
            "removeIndexedAttribute"
        ] = Processor.process_removeIndexedAttribute
        self._processMap[
            "listIndexedAttributes"
        ] = Processor.process_listIndexedAttributes
        self._processMap["getModel"] = Processor.process_getModel
        self._processMap["getRootElements"] = Processor.process_getRootElements
        self._processMap["watchStateChanges"] = Processor.process_watchStateChanges
        self._processMap["watchModelChanges"] = Processor.process_watchModelChanges

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(
                TApplicationException.UNKNOWN_METHOD, "Unknown function %s" % (name)
            )
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_createInstance(self, seqid, iprot, oprot):
        args = createInstance_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createInstance_result()
        try:
            self._handler.createInstance(
                args.name,
                args.backend,
                args.minimumDelayMillis,
                args.maximumDelayMillis,
                args.enabledPlugins,
                args.indexFactory,
            )
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except HawkFactoryNotFound as err1:
            msg_type = TMessageType.REPLY
            result.err1 = err1
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("createInstance", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_listBackends(self, seqid, iprot, oprot):
        args = listBackends_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = listBackends_result()
        try:
            result.success = self._handler.listBackends()
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("listBackends", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_listPlugins(self, seqid, iprot, oprot):
        args = listPlugins_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = listPlugins_result()
        try:
            result.success = self._handler.listPlugins()
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("listPlugins", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_listPluginDetails(self, seqid, iprot, oprot):
        args = listPluginDetails_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = listPluginDetails_result()
        try:
            result.success = self._handler.listPluginDetails()
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("listPluginDetails", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_listInstances(self, seqid, iprot, oprot):
        args = listInstances_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = listInstances_result()
        try:
            result.success = self._handler.listInstances()
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("listInstances", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_removeInstance(self, seqid, iprot, oprot):
        args = removeInstance_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = removeInstance_result()
        try:
            self._handler.removeInstance(args.name)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except HawkInstanceNotFound as err1:
            msg_type = TMessageType.REPLY
            result.err1 = err1
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("removeInstance", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_startInstance(self, seqid, iprot, oprot):
        args = startInstance_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = startInstance_result()
        try:
            self._handler.startInstance(args.name)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except HawkInstanceNotFound as err1:
            msg_type = TMessageType.REPLY
            result.err1 = err1
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("startInstance", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_stopInstance(self, seqid, iprot, oprot):
        args = stopInstance_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = stopInstance_result()
        try:
            self._handler.stopInstance(args.name)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except HawkInstanceNotFound as err1:
            msg_type = TMessageType.REPLY
            result.err1 = err1
        except HawkInstanceNotRunning as err2:
            msg_type = TMessageType.REPLY
            result.err2 = err2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("stopInstance", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_syncInstance(self, seqid, iprot, oprot):
        args = syncInstance_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = syncInstance_result()
        try:
            self._handler.syncInstance(args.name, args.blockUntilDone)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except HawkInstanceNotFound as err1:
            msg_type = TMessageType.REPLY
            result.err1 = err1
        except HawkInstanceNotRunning as err2:
            msg_type = TMessageType.REPLY
            result.err2 = err2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("syncInstance", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_registerMetamodels(self, seqid, iprot, oprot):
        args = registerMetamodels_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = registerMetamodels_result()
        try:
            self._handler.registerMetamodels(args.name, args.metamodel)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except HawkInstanceNotFound as err1:
            msg_type = TMessageType.REPLY
            result.err1 = err1
        except InvalidMetamodel as err2:
            msg_type = TMessageType.REPLY
            result.err2 = err2
        except HawkInstanceNotRunning as err3:
            msg_type = TMessageType.REPLY
            result.err3 = err3
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("registerMetamodels", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_unregisterMetamodels(self, seqid, iprot, oprot):
        args = unregisterMetamodels_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = unregisterMetamodels_result()
        try:
            self._handler.unregisterMetamodels(args.name, args.metamodel)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except HawkInstanceNotFound as err1:
            msg_type = TMessageType.REPLY
            result.err1 = err1
        except HawkInstanceNotRunning as err2:
            msg_type = TMessageType.REPLY
            result.err2 = err2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("unregisterMetamodels", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_listMetamodels(self, seqid, iprot, oprot):
        args = listMetamodels_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = listMetamodels_result()
        try:
            result.success = self._handler.listMetamodels(args.name)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except HawkInstanceNotFound as err1:
            msg_type = TMessageType.REPLY
            result.err1 = err1
        except HawkInstanceNotRunning as err2:
            msg_type = TMessageType.REPLY
            result.err2 = err2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("listMetamodels", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_listTypeNames(self, seqid, iprot, oprot):
        args = listTypeNames_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = listTypeNames_result()
        try:
            result.success = self._handler.listTypeNames(
                args.hawkInstanceName, args.metamodelURI
            )
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except HawkInstanceNotFound as err1:
            msg_type = TMessageType.REPLY
            result.err1 = err1
        except HawkInstanceNotRunning as err2:
            msg_type = TMessageType.REPLY
            result.err2 = err2
        except HawkMetamodelNotFound as err3:
            msg_type = TMessageType.REPLY
            result.err3 = err3
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("listTypeNames", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_listAttributeNames(self, seqid, iprot, oprot):
        args = listAttributeNames_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = listAttributeNames_result()
        try:
            result.success = self._handler.listAttributeNames(
                args.hawkInstanceName, args.metamodelURI, args.typeName
            )
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except HawkInstanceNotFound as err1:
            msg_type = TMessageType.REPLY
            result.err1 = err1
        except HawkInstanceNotRunning as err2:
            msg_type = TMessageType.REPLY
            result.err2 = err2
        except HawkMetamodelNotFound as err3:
            msg_type = TMessageType.REPLY
            result.err3 = err3
        except HawkTypeNotFound as err4:
            msg_type = TMessageType.REPLY
            result.err4 = err4
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("listAttributeNames", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_listMetamodelParsers(self, seqid, iprot, oprot):
        args = listMetamodelParsers_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = listMetamodelParsers_result()
        try:
            result.success = self._handler.listMetamodelParsers(args.name)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except HawkInstanceNotFound as err1:
            msg_type = TMessageType.REPLY
            result.err1 = err1
        except HawkInstanceNotRunning as err2:
            msg_type = TMessageType.REPLY
            result.err2 = err2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("listMetamodelParsers", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_listQueryLanguages(self, seqid, iprot, oprot):
        args = listQueryLanguages_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = listQueryLanguages_result()
        try:
            result.success = self._handler.listQueryLanguages(args.name)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("listQueryLanguages", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query(self, seqid, iprot, oprot):
        args = query_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_result()
        try:
            result.success = self._handler.query(
                args.name, args.query, args.language, args.options
            )
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except HawkInstanceNotFound as err1:
            msg_type = TMessageType.REPLY
            result.err1 = err1
        except HawkInstanceNotRunning as err2:
            msg_type = TMessageType.REPLY
            result.err2 = err2
        except UnknownQueryLanguage as err3:
            msg_type = TMessageType.REPLY
            result.err3 = err3
        except InvalidQuery as err4:
            msg_type = TMessageType.REPLY
            result.err4 = err4
        except FailedQuery as err5:
            msg_type = TMessageType.REPLY
            result.err5 = err5
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("query", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_timedQuery(self, seqid, iprot, oprot):
        args = timedQuery_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = timedQuery_result()
        try:
            result.success = self._handler.timedQuery(
                args.name, args.query, args.language, args.options
            )
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except HawkInstanceNotFound as err1:
            msg_type = TMessageType.REPLY
            result.err1 = err1
        except HawkInstanceNotRunning as err2:
            msg_type = TMessageType.REPLY
            result.err2 = err2
        except UnknownQueryLanguage as err3:
            msg_type = TMessageType.REPLY
            result.err3 = err3
        except InvalidQuery as err4:
            msg_type = TMessageType.REPLY
            result.err4 = err4
        except FailedQuery as err5:
            msg_type = TMessageType.REPLY
            result.err5 = err5
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("timedQuery", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_resolveProxies(self, seqid, iprot, oprot):
        args = resolveProxies_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = resolveProxies_result()
        try:
            result.success = self._handler.resolveProxies(
                args.name, args.ids, args.options
            )
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except HawkInstanceNotFound as err1:
            msg_type = TMessageType.REPLY
            result.err1 = err1
        except HawkInstanceNotRunning as err2:
            msg_type = TMessageType.REPLY
            result.err2 = err2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("resolveProxies", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_asyncQuery(self, seqid, iprot, oprot):
        args = asyncQuery_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = asyncQuery_result()
        try:
            result.success = self._handler.asyncQuery(
                args.name, args.query, args.language, args.options
            )
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except HawkInstanceNotFound as err1:
            msg_type = TMessageType.REPLY
            result.err1 = err1
        except HawkInstanceNotRunning as err2:
            msg_type = TMessageType.REPLY
            result.err2 = err2
        except UnknownQueryLanguage as err3:
            msg_type = TMessageType.REPLY
            result.err3 = err3
        except InvalidQuery as err4:
            msg_type = TMessageType.REPLY
            result.err4 = err4
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("asyncQuery", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_cancelAsyncQuery(self, seqid, iprot, oprot):
        args = cancelAsyncQuery_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = cancelAsyncQuery_result()
        try:
            self._handler.cancelAsyncQuery(args.queryID)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except InvalidQuery as err1:
            msg_type = TMessageType.REPLY
            result.err1 = err1
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("cancelAsyncQuery", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fetchAsyncQueryResults(self, seqid, iprot, oprot):
        args = fetchAsyncQueryResults_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fetchAsyncQueryResults_result()
        try:
            result.success = self._handler.fetchAsyncQueryResults(args.queryID)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except InvalidQuery as err1:
            msg_type = TMessageType.REPLY
            result.err1 = err1
        except FailedQuery as err2:
            msg_type = TMessageType.REPLY
            result.err2 = err2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("fetchAsyncQueryResults", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_addRepository(self, seqid, iprot, oprot):
        args = addRepository_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = addRepository_result()
        try:
            self._handler.addRepository(args.name, args.repo, args.credentials)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except HawkInstanceNotFound as err1:
            msg_type = TMessageType.REPLY
            result.err1 = err1
        except HawkInstanceNotRunning as err2:
            msg_type = TMessageType.REPLY
            result.err2 = err2
        except UnknownRepositoryType as err3:
            msg_type = TMessageType.REPLY
            result.err3 = err3
        except VCSAuthenticationFailed as err4:
            msg_type = TMessageType.REPLY
            result.err4 = err4
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("addRepository", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_isFrozen(self, seqid, iprot, oprot):
        args = isFrozen_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = isFrozen_result()
        try:
            result.success = self._handler.isFrozen(args.name, args.uri)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except HawkInstanceNotFound as err1:
            msg_type = TMessageType.REPLY
            result.err1 = err1
        except HawkInstanceNotRunning as err2:
            msg_type = TMessageType.REPLY
            result.err2 = err2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("isFrozen", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_setFrozen(self, seqid, iprot, oprot):
        args = setFrozen_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = setFrozen_result()
        try:
            self._handler.setFrozen(args.name, args.uri, args.isFrozen)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except HawkInstanceNotFound as err1:
            msg_type = TMessageType.REPLY
            result.err1 = err1
        except HawkInstanceNotRunning as err2:
            msg_type = TMessageType.REPLY
            result.err2 = err2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("setFrozen", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_removeRepository(self, seqid, iprot, oprot):
        args = removeRepository_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = removeRepository_result()
        try:
            self._handler.removeRepository(args.name, args.uri)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except HawkInstanceNotFound as err1:
            msg_type = TMessageType.REPLY
            result.err1 = err1
        except HawkInstanceNotRunning as err2:
            msg_type = TMessageType.REPLY
            result.err2 = err2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("removeRepository", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updateRepositoryCredentials(self, seqid, iprot, oprot):
        args = updateRepositoryCredentials_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateRepositoryCredentials_result()
        try:
            self._handler.updateRepositoryCredentials(args.name, args.uri, args.cred)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except HawkInstanceNotFound as err1:
            msg_type = TMessageType.REPLY
            result.err1 = err1
        except HawkInstanceNotRunning as err2:
            msg_type = TMessageType.REPLY
            result.err2 = err2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("updateRepositoryCredentials", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_listRepositories(self, seqid, iprot, oprot):
        args = listRepositories_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = listRepositories_result()
        try:
            result.success = self._handler.listRepositories(args.name)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except HawkInstanceNotFound as err1:
            msg_type = TMessageType.REPLY
            result.err1 = err1
        except HawkInstanceNotRunning as err2:
            msg_type = TMessageType.REPLY
            result.err2 = err2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("listRepositories", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_listRepositoryTypes(self, seqid, iprot, oprot):
        args = listRepositoryTypes_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = listRepositoryTypes_result()
        try:
            result.success = self._handler.listRepositoryTypes()
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("listRepositoryTypes", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_listFiles(self, seqid, iprot, oprot):
        args = listFiles_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = listFiles_result()
        try:
            result.success = self._handler.listFiles(
                args.name, args.repository, args.filePatterns
            )
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except HawkInstanceNotFound as err1:
            msg_type = TMessageType.REPLY
            result.err1 = err1
        except HawkInstanceNotRunning as err2:
            msg_type = TMessageType.REPLY
            result.err2 = err2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("listFiles", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_configurePolling(self, seqid, iprot, oprot):
        args = configurePolling_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = configurePolling_result()
        try:
            self._handler.configurePolling(args.name, args.base, args.max)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except HawkInstanceNotFound as err1:
            msg_type = TMessageType.REPLY
            result.err1 = err1
        except HawkInstanceNotRunning as err2:
            msg_type = TMessageType.REPLY
            result.err2 = err2
        except InvalidPollingConfiguration as err3:
            msg_type = TMessageType.REPLY
            result.err3 = err3
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("configurePolling", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_addDerivedAttribute(self, seqid, iprot, oprot):
        args = addDerivedAttribute_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = addDerivedAttribute_result()
        try:
            self._handler.addDerivedAttribute(args.name, args.spec)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except HawkInstanceNotFound as err1:
            msg_type = TMessageType.REPLY
            result.err1 = err1
        except HawkInstanceNotRunning as err2:
            msg_type = TMessageType.REPLY
            result.err2 = err2
        except InvalidDerivedAttributeSpec as err3:
            msg_type = TMessageType.REPLY
            result.err3 = err3
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("addDerivedAttribute", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_removeDerivedAttribute(self, seqid, iprot, oprot):
        args = removeDerivedAttribute_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = removeDerivedAttribute_result()
        try:
            self._handler.removeDerivedAttribute(args.name, args.spec)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except HawkInstanceNotFound as err1:
            msg_type = TMessageType.REPLY
            result.err1 = err1
        except HawkInstanceNotRunning as err2:
            msg_type = TMessageType.REPLY
            result.err2 = err2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("removeDerivedAttribute", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_listDerivedAttributes(self, seqid, iprot, oprot):
        args = listDerivedAttributes_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = listDerivedAttributes_result()
        try:
            result.success = self._handler.listDerivedAttributes(args.name)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except HawkInstanceNotFound as err1:
            msg_type = TMessageType.REPLY
            result.err1 = err1
        except HawkInstanceNotRunning as err2:
            msg_type = TMessageType.REPLY
            result.err2 = err2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("listDerivedAttributes", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_addIndexedAttribute(self, seqid, iprot, oprot):
        args = addIndexedAttribute_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = addIndexedAttribute_result()
        try:
            self._handler.addIndexedAttribute(args.name, args.spec)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except HawkInstanceNotFound as err1:
            msg_type = TMessageType.REPLY
            result.err1 = err1
        except HawkInstanceNotRunning as err2:
            msg_type = TMessageType.REPLY
            result.err2 = err2
        except InvalidIndexedAttributeSpec as err3:
            msg_type = TMessageType.REPLY
            result.err3 = err3
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("addIndexedAttribute", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_removeIndexedAttribute(self, seqid, iprot, oprot):
        args = removeIndexedAttribute_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = removeIndexedAttribute_result()
        try:
            self._handler.removeIndexedAttribute(args.name, args.spec)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except HawkInstanceNotFound as err1:
            msg_type = TMessageType.REPLY
            result.err1 = err1
        except HawkInstanceNotRunning as err2:
            msg_type = TMessageType.REPLY
            result.err2 = err2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("removeIndexedAttribute", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_listIndexedAttributes(self, seqid, iprot, oprot):
        args = listIndexedAttributes_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = listIndexedAttributes_result()
        try:
            result.success = self._handler.listIndexedAttributes(args.name)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except HawkInstanceNotFound as err1:
            msg_type = TMessageType.REPLY
            result.err1 = err1
        except HawkInstanceNotRunning as err2:
            msg_type = TMessageType.REPLY
            result.err2 = err2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("listIndexedAttributes", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getModel(self, seqid, iprot, oprot):
        args = getModel_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getModel_result()
        try:
            result.success = self._handler.getModel(args.name, args.options)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except HawkInstanceNotFound as err1:
            msg_type = TMessageType.REPLY
            result.err1 = err1
        except HawkInstanceNotRunning as err2:
            msg_type = TMessageType.REPLY
            result.err2 = err2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("getModel", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getRootElements(self, seqid, iprot, oprot):
        args = getRootElements_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getRootElements_result()
        try:
            result.success = self._handler.getRootElements(args.name, args.options)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("getRootElements", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_watchStateChanges(self, seqid, iprot, oprot):
        args = watchStateChanges_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = watchStateChanges_result()
        try:
            result.success = self._handler.watchStateChanges(args.name)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except HawkInstanceNotFound as err1:
            msg_type = TMessageType.REPLY
            result.err1 = err1
        except HawkInstanceNotRunning as err2:
            msg_type = TMessageType.REPLY
            result.err2 = err2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("watchStateChanges", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_watchModelChanges(self, seqid, iprot, oprot):
        args = watchModelChanges_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = watchModelChanges_result()
        try:
            result.success = self._handler.watchModelChanges(
                args.name,
                args.repositoryUri,
                args.filePath,
                args.clientID,
                args.durableEvents,
            )
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except HawkInstanceNotFound as err1:
            msg_type = TMessageType.REPLY
            result.err1 = err1
        except HawkInstanceNotRunning as err2:
            msg_type = TMessageType.REPLY
            result.err2 = err2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("watchModelChanges", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES


class createInstance_args:
    """
  Attributes:
   - name
   - backend
   - minimumDelayMillis
   - maximumDelayMillis
   - enabledPlugins
   - indexFactory
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "name", None, None,),  # 1
        (2, TType.STRING, "backend", None, None,),  # 2
        (3, TType.I32, "minimumDelayMillis", None, None,),  # 3
        (4, TType.I32, "maximumDelayMillis", None, None,),  # 4
        (5, TType.LIST, "enabledPlugins", (TType.STRING, None), None,),  # 5
        (6, TType.STRING, "indexFactory", None, None,),  # 6
    )

    def __init__(
        self,
        name=None,
        backend=None,
        minimumDelayMillis=None,
        maximumDelayMillis=None,
        enabledPlugins=None,
        indexFactory=None,
    ):
        self.name = name
        self.backend = backend
        self.minimumDelayMillis = minimumDelayMillis
        self.maximumDelayMillis = maximumDelayMillis
        self.enabledPlugins = enabledPlugins
        self.indexFactory = indexFactory

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.backend = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.minimumDelayMillis = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.maximumDelayMillis = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.enabledPlugins = []
                    (_etype202, _size199) = iprot.readListBegin()
                    for _i203 in range(_size199):
                        _elem204 = iprot.readString()
                        self.enabledPlugins.append(_elem204)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.indexFactory = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("createInstance_args")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        if self.backend is not None:
            oprot.writeFieldBegin("backend", TType.STRING, 2)
            oprot.writeString(self.backend)
            oprot.writeFieldEnd()
        if self.minimumDelayMillis is not None:
            oprot.writeFieldBegin("minimumDelayMillis", TType.I32, 3)
            oprot.writeI32(self.minimumDelayMillis)
            oprot.writeFieldEnd()
        if self.maximumDelayMillis is not None:
            oprot.writeFieldBegin("maximumDelayMillis", TType.I32, 4)
            oprot.writeI32(self.maximumDelayMillis)
            oprot.writeFieldEnd()
        if self.enabledPlugins is not None:
            oprot.writeFieldBegin("enabledPlugins", TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.enabledPlugins))
            for iter205 in self.enabledPlugins:
                oprot.writeString(iter205)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.indexFactory is not None:
            oprot.writeFieldBegin("indexFactory", TType.STRING, 6)
            oprot.writeString(self.indexFactory)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocol.TProtocolException(message="Required field name is unset!")
        if self.backend is None:
            raise TProtocol.TProtocolException(
                message="Required field backend is unset!"
            )
        if self.minimumDelayMillis is None:
            raise TProtocol.TProtocolException(
                message="Required field minimumDelayMillis is unset!"
            )
        if self.maximumDelayMillis is None:
            raise TProtocol.TProtocolException(
                message="Required field maximumDelayMillis is unset!"
            )
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.name)
        value = (value * 31) ^ hash(self.backend)
        value = (value * 31) ^ hash(self.minimumDelayMillis)
        value = (value * 31) ^ hash(self.maximumDelayMillis)
        value = (value * 31) ^ hash(self.enabledPlugins)
        value = (value * 31) ^ hash(self.indexFactory)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class createInstance_result:
    """
  Attributes:
   - err1
  """

    thrift_spec = (
        None,  # 0
        (
            1,
            TType.STRUCT,
            "err1",
            (HawkFactoryNotFound, HawkFactoryNotFound.thrift_spec),
            None,
        ),  # 1
    )

    def __init__(
        self, err1=None,
    ):
        self.err1 = err1

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.err1 = HawkFactoryNotFound()
                    self.err1.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("createInstance_result")
        if self.err1 is not None:
            oprot.writeFieldBegin("err1", TType.STRUCT, 1)
            self.err1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.err1)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class listBackends_args:

    thrift_spec = ()

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("listBackends_args")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class listBackends_result:
    """
  Attributes:
   - success
  """

    thrift_spec = ((0, TType.LIST, "success", (TType.STRING, None), None,),)  # 0

    def __init__(
        self, success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype209, _size206) = iprot.readListBegin()
                    for _i210 in range(_size206):
                        _elem211 = iprot.readString()
                        self.success.append(_elem211)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("listBackends_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter212 in self.success:
                oprot.writeString(iter212)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.success)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class listPlugins_args:

    thrift_spec = ()

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("listPlugins_args")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class listPlugins_result:
    """
  Attributes:
   - success
  """

    thrift_spec = ((0, TType.LIST, "success", (TType.STRING, None), None,),)  # 0

    def __init__(
        self, success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype216, _size213) = iprot.readListBegin()
                    for _i217 in range(_size213):
                        _elem218 = iprot.readString()
                        self.success.append(_elem218)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("listPlugins_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter219 in self.success:
                oprot.writeString(iter219)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.success)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class listPluginDetails_args:

    thrift_spec = ()

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("listPluginDetails_args")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class listPluginDetails_result:
    """
  Attributes:
   - success
  """

    thrift_spec = (
        (
            0,
            TType.LIST,
            "success",
            (TType.STRUCT, (HawkPlugin, HawkPlugin.thrift_spec)),
            None,
        ),  # 0
    )

    def __init__(
        self, success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype223, _size220) = iprot.readListBegin()
                    for _i224 in range(_size220):
                        _elem225 = HawkPlugin()
                        _elem225.read(iprot)
                        self.success.append(_elem225)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("listPluginDetails_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter226 in self.success:
                iter226.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.success)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class listInstances_args:

    thrift_spec = ()

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("listInstances_args")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class listInstances_result:
    """
  Attributes:
   - success
  """

    thrift_spec = (
        (
            0,
            TType.LIST,
            "success",
            (TType.STRUCT, (HawkInstance, HawkInstance.thrift_spec)),
            None,
        ),  # 0
    )

    def __init__(
        self, success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype230, _size227) = iprot.readListBegin()
                    for _i231 in range(_size227):
                        _elem232 = HawkInstance()
                        _elem232.read(iprot)
                        self.success.append(_elem232)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("listInstances_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter233 in self.success:
                iter233.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.success)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class removeInstance_args:
    """
  Attributes:
   - name
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "name", None, None,),  # 1
    )

    def __init__(
        self, name=None,
    ):
        self.name = name

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("removeInstance_args")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocol.TProtocolException(message="Required field name is unset!")
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.name)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class removeInstance_result:
    """
  Attributes:
   - err1
  """

    thrift_spec = (
        None,  # 0
        (
            1,
            TType.STRUCT,
            "err1",
            (HawkInstanceNotFound, HawkInstanceNotFound.thrift_spec),
            None,
        ),  # 1
    )

    def __init__(
        self, err1=None,
    ):
        self.err1 = err1

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.err1 = HawkInstanceNotFound()
                    self.err1.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("removeInstance_result")
        if self.err1 is not None:
            oprot.writeFieldBegin("err1", TType.STRUCT, 1)
            self.err1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.err1)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class startInstance_args:
    """
  Attributes:
   - name
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "name", None, None,),  # 1
    )

    def __init__(
        self, name=None,
    ):
        self.name = name

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("startInstance_args")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocol.TProtocolException(message="Required field name is unset!")
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.name)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class startInstance_result:
    """
  Attributes:
   - err1
  """

    thrift_spec = (
        None,  # 0
        (
            1,
            TType.STRUCT,
            "err1",
            (HawkInstanceNotFound, HawkInstanceNotFound.thrift_spec),
            None,
        ),  # 1
    )

    def __init__(
        self, err1=None,
    ):
        self.err1 = err1

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.err1 = HawkInstanceNotFound()
                    self.err1.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("startInstance_result")
        if self.err1 is not None:
            oprot.writeFieldBegin("err1", TType.STRUCT, 1)
            self.err1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.err1)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class stopInstance_args:
    """
  Attributes:
   - name
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "name", None, None,),  # 1
    )

    def __init__(
        self, name=None,
    ):
        self.name = name

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("stopInstance_args")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocol.TProtocolException(message="Required field name is unset!")
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.name)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class stopInstance_result:
    """
  Attributes:
   - err1
   - err2
  """

    thrift_spec = (
        None,  # 0
        (
            1,
            TType.STRUCT,
            "err1",
            (HawkInstanceNotFound, HawkInstanceNotFound.thrift_spec),
            None,
        ),  # 1
        (
            2,
            TType.STRUCT,
            "err2",
            (HawkInstanceNotRunning, HawkInstanceNotRunning.thrift_spec),
            None,
        ),  # 2
    )

    def __init__(
        self, err1=None, err2=None,
    ):
        self.err1 = err1
        self.err2 = err2

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.err1 = HawkInstanceNotFound()
                    self.err1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.err2 = HawkInstanceNotRunning()
                    self.err2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("stopInstance_result")
        if self.err1 is not None:
            oprot.writeFieldBegin("err1", TType.STRUCT, 1)
            self.err1.write(oprot)
            oprot.writeFieldEnd()
        if self.err2 is not None:
            oprot.writeFieldBegin("err2", TType.STRUCT, 2)
            self.err2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.err1)
        value = (value * 31) ^ hash(self.err2)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class syncInstance_args:
    """
  Attributes:
   - name
   - blockUntilDone
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "name", None, None,),  # 1
        (2, TType.BOOL, "blockUntilDone", None, False,),  # 2
    )

    def __init__(
        self, name=None, blockUntilDone=thrift_spec[2][4],
    ):
        self.name = name
        self.blockUntilDone = blockUntilDone

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.blockUntilDone = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("syncInstance_args")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        if self.blockUntilDone is not None:
            oprot.writeFieldBegin("blockUntilDone", TType.BOOL, 2)
            oprot.writeBool(self.blockUntilDone)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocol.TProtocolException(message="Required field name is unset!")
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.name)
        value = (value * 31) ^ hash(self.blockUntilDone)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class syncInstance_result:
    """
  Attributes:
   - err1
   - err2
  """

    thrift_spec = (
        None,  # 0
        (
            1,
            TType.STRUCT,
            "err1",
            (HawkInstanceNotFound, HawkInstanceNotFound.thrift_spec),
            None,
        ),  # 1
        (
            2,
            TType.STRUCT,
            "err2",
            (HawkInstanceNotRunning, HawkInstanceNotRunning.thrift_spec),
            None,
        ),  # 2
    )

    def __init__(
        self, err1=None, err2=None,
    ):
        self.err1 = err1
        self.err2 = err2

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.err1 = HawkInstanceNotFound()
                    self.err1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.err2 = HawkInstanceNotRunning()
                    self.err2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("syncInstance_result")
        if self.err1 is not None:
            oprot.writeFieldBegin("err1", TType.STRUCT, 1)
            self.err1.write(oprot)
            oprot.writeFieldEnd()
        if self.err2 is not None:
            oprot.writeFieldBegin("err2", TType.STRUCT, 2)
            self.err2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.err1)
        value = (value * 31) ^ hash(self.err2)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class registerMetamodels_args:
    """
  Attributes:
   - name
   - metamodel
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "name", None, None,),  # 1
        (
            2,
            TType.LIST,
            "metamodel",
            (TType.STRUCT, (File, File.thrift_spec)),
            None,
        ),  # 2
    )

    def __init__(
        self, name=None, metamodel=None,
    ):
        self.name = name
        self.metamodel = metamodel

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.metamodel = []
                    (_etype237, _size234) = iprot.readListBegin()
                    for _i238 in range(_size234):
                        _elem239 = File()
                        _elem239.read(iprot)
                        self.metamodel.append(_elem239)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("registerMetamodels_args")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        if self.metamodel is not None:
            oprot.writeFieldBegin("metamodel", TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.metamodel))
            for iter240 in self.metamodel:
                iter240.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocol.TProtocolException(message="Required field name is unset!")
        if self.metamodel is None:
            raise TProtocol.TProtocolException(
                message="Required field metamodel is unset!"
            )
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.name)
        value = (value * 31) ^ hash(self.metamodel)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class registerMetamodels_result:
    """
  Attributes:
   - err1
   - err2
   - err3
  """

    thrift_spec = (
        None,  # 0
        (
            1,
            TType.STRUCT,
            "err1",
            (HawkInstanceNotFound, HawkInstanceNotFound.thrift_spec),
            None,
        ),  # 1
        (
            2,
            TType.STRUCT,
            "err2",
            (InvalidMetamodel, InvalidMetamodel.thrift_spec),
            None,
        ),  # 2
        (
            3,
            TType.STRUCT,
            "err3",
            (HawkInstanceNotRunning, HawkInstanceNotRunning.thrift_spec),
            None,
        ),  # 3
    )

    def __init__(
        self, err1=None, err2=None, err3=None,
    ):
        self.err1 = err1
        self.err2 = err2
        self.err3 = err3

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.err1 = HawkInstanceNotFound()
                    self.err1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.err2 = InvalidMetamodel()
                    self.err2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.err3 = HawkInstanceNotRunning()
                    self.err3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("registerMetamodels_result")
        if self.err1 is not None:
            oprot.writeFieldBegin("err1", TType.STRUCT, 1)
            self.err1.write(oprot)
            oprot.writeFieldEnd()
        if self.err2 is not None:
            oprot.writeFieldBegin("err2", TType.STRUCT, 2)
            self.err2.write(oprot)
            oprot.writeFieldEnd()
        if self.err3 is not None:
            oprot.writeFieldBegin("err3", TType.STRUCT, 3)
            self.err3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.err1)
        value = (value * 31) ^ hash(self.err2)
        value = (value * 31) ^ hash(self.err3)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class unregisterMetamodels_args:
    """
  Attributes:
   - name
   - metamodel
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "name", None, None,),  # 1
        (2, TType.LIST, "metamodel", (TType.STRING, None), None,),  # 2
    )

    def __init__(
        self, name=None, metamodel=None,
    ):
        self.name = name
        self.metamodel = metamodel

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.metamodel = []
                    (_etype244, _size241) = iprot.readListBegin()
                    for _i245 in range(_size241):
                        _elem246 = iprot.readString()
                        self.metamodel.append(_elem246)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("unregisterMetamodels_args")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        if self.metamodel is not None:
            oprot.writeFieldBegin("metamodel", TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.metamodel))
            for iter247 in self.metamodel:
                oprot.writeString(iter247)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocol.TProtocolException(message="Required field name is unset!")
        if self.metamodel is None:
            raise TProtocol.TProtocolException(
                message="Required field metamodel is unset!"
            )
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.name)
        value = (value * 31) ^ hash(self.metamodel)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class unregisterMetamodels_result:
    """
  Attributes:
   - err1
   - err2
  """

    thrift_spec = (
        None,  # 0
        (
            1,
            TType.STRUCT,
            "err1",
            (HawkInstanceNotFound, HawkInstanceNotFound.thrift_spec),
            None,
        ),  # 1
        (
            2,
            TType.STRUCT,
            "err2",
            (HawkInstanceNotRunning, HawkInstanceNotRunning.thrift_spec),
            None,
        ),  # 2
    )

    def __init__(
        self, err1=None, err2=None,
    ):
        self.err1 = err1
        self.err2 = err2

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.err1 = HawkInstanceNotFound()
                    self.err1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.err2 = HawkInstanceNotRunning()
                    self.err2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("unregisterMetamodels_result")
        if self.err1 is not None:
            oprot.writeFieldBegin("err1", TType.STRUCT, 1)
            self.err1.write(oprot)
            oprot.writeFieldEnd()
        if self.err2 is not None:
            oprot.writeFieldBegin("err2", TType.STRUCT, 2)
            self.err2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.err1)
        value = (value * 31) ^ hash(self.err2)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class listMetamodels_args:
    """
  Attributes:
   - name
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "name", None, None,),  # 1
    )

    def __init__(
        self, name=None,
    ):
        self.name = name

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("listMetamodels_args")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocol.TProtocolException(message="Required field name is unset!")
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.name)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class listMetamodels_result:
    """
  Attributes:
   - success
   - err1
   - err2
  """

    thrift_spec = (
        (0, TType.LIST, "success", (TType.STRING, None), None,),  # 0
        (
            1,
            TType.STRUCT,
            "err1",
            (HawkInstanceNotFound, HawkInstanceNotFound.thrift_spec),
            None,
        ),  # 1
        (
            2,
            TType.STRUCT,
            "err2",
            (HawkInstanceNotRunning, HawkInstanceNotRunning.thrift_spec),
            None,
        ),  # 2
    )

    def __init__(
        self, success=None, err1=None, err2=None,
    ):
        self.success = success
        self.err1 = err1
        self.err2 = err2

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype251, _size248) = iprot.readListBegin()
                    for _i252 in range(_size248):
                        _elem253 = iprot.readString()
                        self.success.append(_elem253)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.err1 = HawkInstanceNotFound()
                    self.err1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.err2 = HawkInstanceNotRunning()
                    self.err2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("listMetamodels_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter254 in self.success:
                oprot.writeString(iter254)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.err1 is not None:
            oprot.writeFieldBegin("err1", TType.STRUCT, 1)
            self.err1.write(oprot)
            oprot.writeFieldEnd()
        if self.err2 is not None:
            oprot.writeFieldBegin("err2", TType.STRUCT, 2)
            self.err2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.success)
        value = (value * 31) ^ hash(self.err1)
        value = (value * 31) ^ hash(self.err2)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class listTypeNames_args:
    """
  Attributes:
   - hawkInstanceName
   - metamodelURI
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "hawkInstanceName", None, None,),  # 1
        (2, TType.STRING, "metamodelURI", None, None,),  # 2
    )

    def __init__(
        self, hawkInstanceName=None, metamodelURI=None,
    ):
        self.hawkInstanceName = hawkInstanceName
        self.metamodelURI = metamodelURI

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.hawkInstanceName = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.metamodelURI = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("listTypeNames_args")
        if self.hawkInstanceName is not None:
            oprot.writeFieldBegin("hawkInstanceName", TType.STRING, 1)
            oprot.writeString(self.hawkInstanceName)
            oprot.writeFieldEnd()
        if self.metamodelURI is not None:
            oprot.writeFieldBegin("metamodelURI", TType.STRING, 2)
            oprot.writeString(self.metamodelURI)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.hawkInstanceName is None:
            raise TProtocol.TProtocolException(
                message="Required field hawkInstanceName is unset!"
            )
        if self.metamodelURI is None:
            raise TProtocol.TProtocolException(
                message="Required field metamodelURI is unset!"
            )
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.hawkInstanceName)
        value = (value * 31) ^ hash(self.metamodelURI)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class listTypeNames_result:
    """
  Attributes:
   - success
   - err1
   - err2
   - err3
  """

    thrift_spec = (
        (0, TType.LIST, "success", (TType.STRING, None), None,),  # 0
        (
            1,
            TType.STRUCT,
            "err1",
            (HawkInstanceNotFound, HawkInstanceNotFound.thrift_spec),
            None,
        ),  # 1
        (
            2,
            TType.STRUCT,
            "err2",
            (HawkInstanceNotRunning, HawkInstanceNotRunning.thrift_spec),
            None,
        ),  # 2
        (
            3,
            TType.STRUCT,
            "err3",
            (HawkMetamodelNotFound, HawkMetamodelNotFound.thrift_spec),
            None,
        ),  # 3
    )

    def __init__(
        self, success=None, err1=None, err2=None, err3=None,
    ):
        self.success = success
        self.err1 = err1
        self.err2 = err2
        self.err3 = err3

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype258, _size255) = iprot.readListBegin()
                    for _i259 in range(_size255):
                        _elem260 = iprot.readString()
                        self.success.append(_elem260)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.err1 = HawkInstanceNotFound()
                    self.err1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.err2 = HawkInstanceNotRunning()
                    self.err2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.err3 = HawkMetamodelNotFound()
                    self.err3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("listTypeNames_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter261 in self.success:
                oprot.writeString(iter261)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.err1 is not None:
            oprot.writeFieldBegin("err1", TType.STRUCT, 1)
            self.err1.write(oprot)
            oprot.writeFieldEnd()
        if self.err2 is not None:
            oprot.writeFieldBegin("err2", TType.STRUCT, 2)
            self.err2.write(oprot)
            oprot.writeFieldEnd()
        if self.err3 is not None:
            oprot.writeFieldBegin("err3", TType.STRUCT, 3)
            self.err3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.success)
        value = (value * 31) ^ hash(self.err1)
        value = (value * 31) ^ hash(self.err2)
        value = (value * 31) ^ hash(self.err3)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class listAttributeNames_args:
    """
  Attributes:
   - hawkInstanceName
   - metamodelURI
   - typeName
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "hawkInstanceName", None, None,),  # 1
        (2, TType.STRING, "metamodelURI", None, None,),  # 2
        (3, TType.STRING, "typeName", None, None,),  # 3
    )

    def __init__(
        self, hawkInstanceName=None, metamodelURI=None, typeName=None,
    ):
        self.hawkInstanceName = hawkInstanceName
        self.metamodelURI = metamodelURI
        self.typeName = typeName

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.hawkInstanceName = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.metamodelURI = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.typeName = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("listAttributeNames_args")
        if self.hawkInstanceName is not None:
            oprot.writeFieldBegin("hawkInstanceName", TType.STRING, 1)
            oprot.writeString(self.hawkInstanceName)
            oprot.writeFieldEnd()
        if self.metamodelURI is not None:
            oprot.writeFieldBegin("metamodelURI", TType.STRING, 2)
            oprot.writeString(self.metamodelURI)
            oprot.writeFieldEnd()
        if self.typeName is not None:
            oprot.writeFieldBegin("typeName", TType.STRING, 3)
            oprot.writeString(self.typeName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.hawkInstanceName is None:
            raise TProtocol.TProtocolException(
                message="Required field hawkInstanceName is unset!"
            )
        if self.metamodelURI is None:
            raise TProtocol.TProtocolException(
                message="Required field metamodelURI is unset!"
            )
        if self.typeName is None:
            raise TProtocol.TProtocolException(
                message="Required field typeName is unset!"
            )
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.hawkInstanceName)
        value = (value * 31) ^ hash(self.metamodelURI)
        value = (value * 31) ^ hash(self.typeName)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class listAttributeNames_result:
    """
  Attributes:
   - success
   - err1
   - err2
   - err3
   - err4
  """

    thrift_spec = (
        (0, TType.LIST, "success", (TType.STRING, None), None,),  # 0
        (
            1,
            TType.STRUCT,
            "err1",
            (HawkInstanceNotFound, HawkInstanceNotFound.thrift_spec),
            None,
        ),  # 1
        (
            2,
            TType.STRUCT,
            "err2",
            (HawkInstanceNotRunning, HawkInstanceNotRunning.thrift_spec),
            None,
        ),  # 2
        (
            3,
            TType.STRUCT,
            "err3",
            (HawkMetamodelNotFound, HawkMetamodelNotFound.thrift_spec),
            None,
        ),  # 3
        (
            4,
            TType.STRUCT,
            "err4",
            (HawkTypeNotFound, HawkTypeNotFound.thrift_spec),
            None,
        ),  # 4
    )

    def __init__(
        self, success=None, err1=None, err2=None, err3=None, err4=None,
    ):
        self.success = success
        self.err1 = err1
        self.err2 = err2
        self.err3 = err3
        self.err4 = err4

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype265, _size262) = iprot.readListBegin()
                    for _i266 in range(_size262):
                        _elem267 = iprot.readString()
                        self.success.append(_elem267)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.err1 = HawkInstanceNotFound()
                    self.err1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.err2 = HawkInstanceNotRunning()
                    self.err2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.err3 = HawkMetamodelNotFound()
                    self.err3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.err4 = HawkTypeNotFound()
                    self.err4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("listAttributeNames_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter268 in self.success:
                oprot.writeString(iter268)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.err1 is not None:
            oprot.writeFieldBegin("err1", TType.STRUCT, 1)
            self.err1.write(oprot)
            oprot.writeFieldEnd()
        if self.err2 is not None:
            oprot.writeFieldBegin("err2", TType.STRUCT, 2)
            self.err2.write(oprot)
            oprot.writeFieldEnd()
        if self.err3 is not None:
            oprot.writeFieldBegin("err3", TType.STRUCT, 3)
            self.err3.write(oprot)
            oprot.writeFieldEnd()
        if self.err4 is not None:
            oprot.writeFieldBegin("err4", TType.STRUCT, 4)
            self.err4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.success)
        value = (value * 31) ^ hash(self.err1)
        value = (value * 31) ^ hash(self.err2)
        value = (value * 31) ^ hash(self.err3)
        value = (value * 31) ^ hash(self.err4)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class listMetamodelParsers_args:
    """
  Attributes:
   - name
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "name", None, None,),  # 1
    )

    def __init__(
        self, name=None,
    ):
        self.name = name

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("listMetamodelParsers_args")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocol.TProtocolException(message="Required field name is unset!")
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.name)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class listMetamodelParsers_result:
    """
  Attributes:
   - success
   - err1
   - err2
  """

    thrift_spec = (
        (
            0,
            TType.LIST,
            "success",
            (
                TType.STRUCT,
                (MetamodelParserDetails, MetamodelParserDetails.thrift_spec),
            ),
            None,
        ),  # 0
        (
            1,
            TType.STRUCT,
            "err1",
            (HawkInstanceNotFound, HawkInstanceNotFound.thrift_spec),
            None,
        ),  # 1
        (
            2,
            TType.STRUCT,
            "err2",
            (HawkInstanceNotRunning, HawkInstanceNotRunning.thrift_spec),
            None,
        ),  # 2
    )

    def __init__(
        self, success=None, err1=None, err2=None,
    ):
        self.success = success
        self.err1 = err1
        self.err2 = err2

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype272, _size269) = iprot.readListBegin()
                    for _i273 in range(_size269):
                        _elem274 = MetamodelParserDetails()
                        _elem274.read(iprot)
                        self.success.append(_elem274)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.err1 = HawkInstanceNotFound()
                    self.err1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.err2 = HawkInstanceNotRunning()
                    self.err2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("listMetamodelParsers_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter275 in self.success:
                iter275.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.err1 is not None:
            oprot.writeFieldBegin("err1", TType.STRUCT, 1)
            self.err1.write(oprot)
            oprot.writeFieldEnd()
        if self.err2 is not None:
            oprot.writeFieldBegin("err2", TType.STRUCT, 2)
            self.err2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.success)
        value = (value * 31) ^ hash(self.err1)
        value = (value * 31) ^ hash(self.err2)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class listQueryLanguages_args:
    """
  Attributes:
   - name
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "name", None, None,),  # 1
    )

    def __init__(
        self, name=None,
    ):
        self.name = name

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("listQueryLanguages_args")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocol.TProtocolException(message="Required field name is unset!")
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.name)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class listQueryLanguages_result:
    """
  Attributes:
   - success
  """

    thrift_spec = ((0, TType.LIST, "success", (TType.STRING, None), None,),)  # 0

    def __init__(
        self, success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype279, _size276) = iprot.readListBegin()
                    for _i280 in range(_size276):
                        _elem281 = iprot.readString()
                        self.success.append(_elem281)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("listQueryLanguages_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter282 in self.success:
                oprot.writeString(iter282)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.success)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class query_args:
    """
  Attributes:
   - name
   - query
   - language
   - options
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "name", None, None,),  # 1
        (2, TType.STRING, "query", None, None,),  # 2
        (3, TType.STRING, "language", None, None,),  # 3
        (
            4,
            TType.STRUCT,
            "options",
            (HawkQueryOptions, HawkQueryOptions.thrift_spec),
            None,
        ),  # 4
    )

    def __init__(
        self, name=None, query=None, language=None, options=None,
    ):
        self.name = name
        self.query = query
        self.language = language
        self.options = options

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.query = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.language = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.options = HawkQueryOptions()
                    self.options.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("query_args")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        if self.query is not None:
            oprot.writeFieldBegin("query", TType.STRING, 2)
            oprot.writeString(self.query)
            oprot.writeFieldEnd()
        if self.language is not None:
            oprot.writeFieldBegin("language", TType.STRING, 3)
            oprot.writeString(self.language)
            oprot.writeFieldEnd()
        if self.options is not None:
            oprot.writeFieldBegin("options", TType.STRUCT, 4)
            self.options.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocol.TProtocolException(message="Required field name is unset!")
        if self.query is None:
            raise TProtocol.TProtocolException(message="Required field query is unset!")
        if self.language is None:
            raise TProtocol.TProtocolException(
                message="Required field language is unset!"
            )
        if self.options is None:
            raise TProtocol.TProtocolException(
                message="Required field options is unset!"
            )
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.name)
        value = (value * 31) ^ hash(self.query)
        value = (value * 31) ^ hash(self.language)
        value = (value * 31) ^ hash(self.options)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class query_result:
    """
  Attributes:
   - success
   - err1
   - err2
   - err3
   - err4
   - err5
  """

    thrift_spec = (
        (
            0,
            TType.STRUCT,
            "success",
            (QueryResult, QueryResult.thrift_spec),
            None,
        ),  # 0
        (
            1,
            TType.STRUCT,
            "err1",
            (HawkInstanceNotFound, HawkInstanceNotFound.thrift_spec),
            None,
        ),  # 1
        (
            2,
            TType.STRUCT,
            "err2",
            (HawkInstanceNotRunning, HawkInstanceNotRunning.thrift_spec),
            None,
        ),  # 2
        (
            3,
            TType.STRUCT,
            "err3",
            (UnknownQueryLanguage, UnknownQueryLanguage.thrift_spec),
            None,
        ),  # 3
        (4, TType.STRUCT, "err4", (InvalidQuery, InvalidQuery.thrift_spec), None,),  # 4
        (5, TType.STRUCT, "err5", (FailedQuery, FailedQuery.thrift_spec), None,),  # 5
    )

    def __init__(
        self, success=None, err1=None, err2=None, err3=None, err4=None, err5=None,
    ):
        self.success = success
        self.err1 = err1
        self.err2 = err2
        self.err3 = err3
        self.err4 = err4
        self.err5 = err5

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = QueryResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.err1 = HawkInstanceNotFound()
                    self.err1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.err2 = HawkInstanceNotRunning()
                    self.err2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.err3 = UnknownQueryLanguage()
                    self.err3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.err4 = InvalidQuery()
                    self.err4.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.err5 = FailedQuery()
                    self.err5.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("query_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.err1 is not None:
            oprot.writeFieldBegin("err1", TType.STRUCT, 1)
            self.err1.write(oprot)
            oprot.writeFieldEnd()
        if self.err2 is not None:
            oprot.writeFieldBegin("err2", TType.STRUCT, 2)
            self.err2.write(oprot)
            oprot.writeFieldEnd()
        if self.err3 is not None:
            oprot.writeFieldBegin("err3", TType.STRUCT, 3)
            self.err3.write(oprot)
            oprot.writeFieldEnd()
        if self.err4 is not None:
            oprot.writeFieldBegin("err4", TType.STRUCT, 4)
            self.err4.write(oprot)
            oprot.writeFieldEnd()
        if self.err5 is not None:
            oprot.writeFieldBegin("err5", TType.STRUCT, 5)
            self.err5.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.success)
        value = (value * 31) ^ hash(self.err1)
        value = (value * 31) ^ hash(self.err2)
        value = (value * 31) ^ hash(self.err3)
        value = (value * 31) ^ hash(self.err4)
        value = (value * 31) ^ hash(self.err5)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class timedQuery_args:
    """
  Attributes:
   - name
   - query
   - language
   - options
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "name", None, None,),  # 1
        (2, TType.STRING, "query", None, None,),  # 2
        (3, TType.STRING, "language", None, None,),  # 3
        (
            4,
            TType.STRUCT,
            "options",
            (HawkQueryOptions, HawkQueryOptions.thrift_spec),
            None,
        ),  # 4
    )

    def __init__(
        self, name=None, query=None, language=None, options=None,
    ):
        self.name = name
        self.query = query
        self.language = language
        self.options = options

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.query = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.language = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.options = HawkQueryOptions()
                    self.options.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("timedQuery_args")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        if self.query is not None:
            oprot.writeFieldBegin("query", TType.STRING, 2)
            oprot.writeString(self.query)
            oprot.writeFieldEnd()
        if self.language is not None:
            oprot.writeFieldBegin("language", TType.STRING, 3)
            oprot.writeString(self.language)
            oprot.writeFieldEnd()
        if self.options is not None:
            oprot.writeFieldBegin("options", TType.STRUCT, 4)
            self.options.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocol.TProtocolException(message="Required field name is unset!")
        if self.query is None:
            raise TProtocol.TProtocolException(message="Required field query is unset!")
        if self.language is None:
            raise TProtocol.TProtocolException(
                message="Required field language is unset!"
            )
        if self.options is None:
            raise TProtocol.TProtocolException(
                message="Required field options is unset!"
            )
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.name)
        value = (value * 31) ^ hash(self.query)
        value = (value * 31) ^ hash(self.language)
        value = (value * 31) ^ hash(self.options)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class timedQuery_result:
    """
  Attributes:
   - success
   - err1
   - err2
   - err3
   - err4
   - err5
  """

    thrift_spec = (
        (
            0,
            TType.STRUCT,
            "success",
            (QueryReport, QueryReport.thrift_spec),
            None,
        ),  # 0
        (
            1,
            TType.STRUCT,
            "err1",
            (HawkInstanceNotFound, HawkInstanceNotFound.thrift_spec),
            None,
        ),  # 1
        (
            2,
            TType.STRUCT,
            "err2",
            (HawkInstanceNotRunning, HawkInstanceNotRunning.thrift_spec),
            None,
        ),  # 2
        (
            3,
            TType.STRUCT,
            "err3",
            (UnknownQueryLanguage, UnknownQueryLanguage.thrift_spec),
            None,
        ),  # 3
        (4, TType.STRUCT, "err4", (InvalidQuery, InvalidQuery.thrift_spec), None,),  # 4
        (5, TType.STRUCT, "err5", (FailedQuery, FailedQuery.thrift_spec), None,),  # 5
    )

    def __init__(
        self, success=None, err1=None, err2=None, err3=None, err4=None, err5=None,
    ):
        self.success = success
        self.err1 = err1
        self.err2 = err2
        self.err3 = err3
        self.err4 = err4
        self.err5 = err5

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = QueryReport()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.err1 = HawkInstanceNotFound()
                    self.err1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.err2 = HawkInstanceNotRunning()
                    self.err2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.err3 = UnknownQueryLanguage()
                    self.err3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.err4 = InvalidQuery()
                    self.err4.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.err5 = FailedQuery()
                    self.err5.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("timedQuery_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.err1 is not None:
            oprot.writeFieldBegin("err1", TType.STRUCT, 1)
            self.err1.write(oprot)
            oprot.writeFieldEnd()
        if self.err2 is not None:
            oprot.writeFieldBegin("err2", TType.STRUCT, 2)
            self.err2.write(oprot)
            oprot.writeFieldEnd()
        if self.err3 is not None:
            oprot.writeFieldBegin("err3", TType.STRUCT, 3)
            self.err3.write(oprot)
            oprot.writeFieldEnd()
        if self.err4 is not None:
            oprot.writeFieldBegin("err4", TType.STRUCT, 4)
            self.err4.write(oprot)
            oprot.writeFieldEnd()
        if self.err5 is not None:
            oprot.writeFieldBegin("err5", TType.STRUCT, 5)
            self.err5.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.success)
        value = (value * 31) ^ hash(self.err1)
        value = (value * 31) ^ hash(self.err2)
        value = (value * 31) ^ hash(self.err3)
        value = (value * 31) ^ hash(self.err4)
        value = (value * 31) ^ hash(self.err5)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class resolveProxies_args:
    """
  Attributes:
   - name
   - ids
   - options
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "name", None, None,),  # 1
        (2, TType.LIST, "ids", (TType.STRING, None), None,),  # 2
        (
            3,
            TType.STRUCT,
            "options",
            (HawkQueryOptions, HawkQueryOptions.thrift_spec),
            None,
        ),  # 3
    )

    def __init__(
        self, name=None, ids=None, options=None,
    ):
        self.name = name
        self.ids = ids
        self.options = options

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.ids = []
                    (_etype286, _size283) = iprot.readListBegin()
                    for _i287 in range(_size283):
                        _elem288 = iprot.readString()
                        self.ids.append(_elem288)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.options = HawkQueryOptions()
                    self.options.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("resolveProxies_args")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        if self.ids is not None:
            oprot.writeFieldBegin("ids", TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.ids))
            for iter289 in self.ids:
                oprot.writeString(iter289)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.options is not None:
            oprot.writeFieldBegin("options", TType.STRUCT, 3)
            self.options.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocol.TProtocolException(message="Required field name is unset!")
        if self.ids is None:
            raise TProtocol.TProtocolException(message="Required field ids is unset!")
        if self.options is None:
            raise TProtocol.TProtocolException(
                message="Required field options is unset!"
            )
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.name)
        value = (value * 31) ^ hash(self.ids)
        value = (value * 31) ^ hash(self.options)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class resolveProxies_result:
    """
  Attributes:
   - success
   - err1
   - err2
  """

    thrift_spec = (
        (
            0,
            TType.LIST,
            "success",
            (TType.STRUCT, (ModelElement, ModelElement.thrift_spec)),
            None,
        ),  # 0
        (
            1,
            TType.STRUCT,
            "err1",
            (HawkInstanceNotFound, HawkInstanceNotFound.thrift_spec),
            None,
        ),  # 1
        (
            2,
            TType.STRUCT,
            "err2",
            (HawkInstanceNotRunning, HawkInstanceNotRunning.thrift_spec),
            None,
        ),  # 2
    )

    def __init__(
        self, success=None, err1=None, err2=None,
    ):
        self.success = success
        self.err1 = err1
        self.err2 = err2

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype293, _size290) = iprot.readListBegin()
                    for _i294 in range(_size290):
                        _elem295 = ModelElement()
                        _elem295.read(iprot)
                        self.success.append(_elem295)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.err1 = HawkInstanceNotFound()
                    self.err1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.err2 = HawkInstanceNotRunning()
                    self.err2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("resolveProxies_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter296 in self.success:
                iter296.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.err1 is not None:
            oprot.writeFieldBegin("err1", TType.STRUCT, 1)
            self.err1.write(oprot)
            oprot.writeFieldEnd()
        if self.err2 is not None:
            oprot.writeFieldBegin("err2", TType.STRUCT, 2)
            self.err2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.success)
        value = (value * 31) ^ hash(self.err1)
        value = (value * 31) ^ hash(self.err2)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class asyncQuery_args:
    """
  Attributes:
   - name
   - query
   - language
   - options
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "name", None, None,),  # 1
        (2, TType.STRING, "query", None, None,),  # 2
        (3, TType.STRING, "language", None, None,),  # 3
        (
            4,
            TType.STRUCT,
            "options",
            (HawkQueryOptions, HawkQueryOptions.thrift_spec),
            None,
        ),  # 4
    )

    def __init__(
        self, name=None, query=None, language=None, options=None,
    ):
        self.name = name
        self.query = query
        self.language = language
        self.options = options

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.query = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.language = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.options = HawkQueryOptions()
                    self.options.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("asyncQuery_args")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        if self.query is not None:
            oprot.writeFieldBegin("query", TType.STRING, 2)
            oprot.writeString(self.query)
            oprot.writeFieldEnd()
        if self.language is not None:
            oprot.writeFieldBegin("language", TType.STRING, 3)
            oprot.writeString(self.language)
            oprot.writeFieldEnd()
        if self.options is not None:
            oprot.writeFieldBegin("options", TType.STRUCT, 4)
            self.options.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocol.TProtocolException(message="Required field name is unset!")
        if self.query is None:
            raise TProtocol.TProtocolException(message="Required field query is unset!")
        if self.language is None:
            raise TProtocol.TProtocolException(
                message="Required field language is unset!"
            )
        if self.options is None:
            raise TProtocol.TProtocolException(
                message="Required field options is unset!"
            )
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.name)
        value = (value * 31) ^ hash(self.query)
        value = (value * 31) ^ hash(self.language)
        value = (value * 31) ^ hash(self.options)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class asyncQuery_result:
    """
  Attributes:
   - success
   - err1
   - err2
   - err3
   - err4
  """

    thrift_spec = (
        (0, TType.STRING, "success", None, None,),  # 0
        (
            1,
            TType.STRUCT,
            "err1",
            (HawkInstanceNotFound, HawkInstanceNotFound.thrift_spec),
            None,
        ),  # 1
        (
            2,
            TType.STRUCT,
            "err2",
            (HawkInstanceNotRunning, HawkInstanceNotRunning.thrift_spec),
            None,
        ),  # 2
        (
            3,
            TType.STRUCT,
            "err3",
            (UnknownQueryLanguage, UnknownQueryLanguage.thrift_spec),
            None,
        ),  # 3
        (4, TType.STRUCT, "err4", (InvalidQuery, InvalidQuery.thrift_spec), None,),  # 4
    )

    def __init__(
        self, success=None, err1=None, err2=None, err3=None, err4=None,
    ):
        self.success = success
        self.err1 = err1
        self.err2 = err2
        self.err3 = err3
        self.err4 = err4

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.err1 = HawkInstanceNotFound()
                    self.err1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.err2 = HawkInstanceNotRunning()
                    self.err2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.err3 = UnknownQueryLanguage()
                    self.err3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.err4 = InvalidQuery()
                    self.err4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("asyncQuery_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRING, 0)
            oprot.writeString(self.success)
            oprot.writeFieldEnd()
        if self.err1 is not None:
            oprot.writeFieldBegin("err1", TType.STRUCT, 1)
            self.err1.write(oprot)
            oprot.writeFieldEnd()
        if self.err2 is not None:
            oprot.writeFieldBegin("err2", TType.STRUCT, 2)
            self.err2.write(oprot)
            oprot.writeFieldEnd()
        if self.err3 is not None:
            oprot.writeFieldBegin("err3", TType.STRUCT, 3)
            self.err3.write(oprot)
            oprot.writeFieldEnd()
        if self.err4 is not None:
            oprot.writeFieldBegin("err4", TType.STRUCT, 4)
            self.err4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.success)
        value = (value * 31) ^ hash(self.err1)
        value = (value * 31) ^ hash(self.err2)
        value = (value * 31) ^ hash(self.err3)
        value = (value * 31) ^ hash(self.err4)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class cancelAsyncQuery_args:
    """
  Attributes:
   - queryID
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "queryID", None, None,),  # 1
    )

    def __init__(
        self, queryID=None,
    ):
        self.queryID = queryID

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.queryID = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("cancelAsyncQuery_args")
        if self.queryID is not None:
            oprot.writeFieldBegin("queryID", TType.STRING, 1)
            oprot.writeString(self.queryID)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.queryID is None:
            raise TProtocol.TProtocolException(
                message="Required field queryID is unset!"
            )
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.queryID)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class cancelAsyncQuery_result:
    """
  Attributes:
   - err1
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, "err1", (InvalidQuery, InvalidQuery.thrift_spec), None,),  # 1
    )

    def __init__(
        self, err1=None,
    ):
        self.err1 = err1

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.err1 = InvalidQuery()
                    self.err1.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("cancelAsyncQuery_result")
        if self.err1 is not None:
            oprot.writeFieldBegin("err1", TType.STRUCT, 1)
            self.err1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.err1)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class fetchAsyncQueryResults_args:
    """
  Attributes:
   - queryID
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "queryID", None, None,),  # 1
    )

    def __init__(
        self, queryID=None,
    ):
        self.queryID = queryID

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.queryID = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("fetchAsyncQueryResults_args")
        if self.queryID is not None:
            oprot.writeFieldBegin("queryID", TType.STRING, 1)
            oprot.writeString(self.queryID)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.queryID is None:
            raise TProtocol.TProtocolException(
                message="Required field queryID is unset!"
            )
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.queryID)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class fetchAsyncQueryResults_result:
    """
  Attributes:
   - success
   - err1
   - err2
  """

    thrift_spec = (
        (
            0,
            TType.STRUCT,
            "success",
            (QueryReport, QueryReport.thrift_spec),
            None,
        ),  # 0
        (1, TType.STRUCT, "err1", (InvalidQuery, InvalidQuery.thrift_spec), None,),  # 1
        (2, TType.STRUCT, "err2", (FailedQuery, FailedQuery.thrift_spec), None,),  # 2
    )

    def __init__(
        self, success=None, err1=None, err2=None,
    ):
        self.success = success
        self.err1 = err1
        self.err2 = err2

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = QueryReport()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.err1 = InvalidQuery()
                    self.err1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.err2 = FailedQuery()
                    self.err2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("fetchAsyncQueryResults_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.err1 is not None:
            oprot.writeFieldBegin("err1", TType.STRUCT, 1)
            self.err1.write(oprot)
            oprot.writeFieldEnd()
        if self.err2 is not None:
            oprot.writeFieldBegin("err2", TType.STRUCT, 2)
            self.err2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.success)
        value = (value * 31) ^ hash(self.err1)
        value = (value * 31) ^ hash(self.err2)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class addRepository_args:
    """
  Attributes:
   - name
   - repo
   - credentials
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "name", None, None,),  # 1
        (2, TType.STRUCT, "repo", (Repository, Repository.thrift_spec), None,),  # 2
        (
            3,
            TType.STRUCT,
            "credentials",
            (Credentials, Credentials.thrift_spec),
            None,
        ),  # 3
    )

    def __init__(
        self, name=None, repo=None, credentials=None,
    ):
        self.name = name
        self.repo = repo
        self.credentials = credentials

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.repo = Repository()
                    self.repo.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.credentials = Credentials()
                    self.credentials.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("addRepository_args")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        if self.repo is not None:
            oprot.writeFieldBegin("repo", TType.STRUCT, 2)
            self.repo.write(oprot)
            oprot.writeFieldEnd()
        if self.credentials is not None:
            oprot.writeFieldBegin("credentials", TType.STRUCT, 3)
            self.credentials.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocol.TProtocolException(message="Required field name is unset!")
        if self.repo is None:
            raise TProtocol.TProtocolException(message="Required field repo is unset!")
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.name)
        value = (value * 31) ^ hash(self.repo)
        value = (value * 31) ^ hash(self.credentials)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class addRepository_result:
    """
  Attributes:
   - err1
   - err2
   - err3
   - err4
  """

    thrift_spec = (
        None,  # 0
        (
            1,
            TType.STRUCT,
            "err1",
            (HawkInstanceNotFound, HawkInstanceNotFound.thrift_spec),
            None,
        ),  # 1
        (
            2,
            TType.STRUCT,
            "err2",
            (HawkInstanceNotRunning, HawkInstanceNotRunning.thrift_spec),
            None,
        ),  # 2
        (
            3,
            TType.STRUCT,
            "err3",
            (UnknownRepositoryType, UnknownRepositoryType.thrift_spec),
            None,
        ),  # 3
        (
            4,
            TType.STRUCT,
            "err4",
            (VCSAuthenticationFailed, VCSAuthenticationFailed.thrift_spec),
            None,
        ),  # 4
    )

    def __init__(
        self, err1=None, err2=None, err3=None, err4=None,
    ):
        self.err1 = err1
        self.err2 = err2
        self.err3 = err3
        self.err4 = err4

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.err1 = HawkInstanceNotFound()
                    self.err1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.err2 = HawkInstanceNotRunning()
                    self.err2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.err3 = UnknownRepositoryType()
                    self.err3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.err4 = VCSAuthenticationFailed()
                    self.err4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("addRepository_result")
        if self.err1 is not None:
            oprot.writeFieldBegin("err1", TType.STRUCT, 1)
            self.err1.write(oprot)
            oprot.writeFieldEnd()
        if self.err2 is not None:
            oprot.writeFieldBegin("err2", TType.STRUCT, 2)
            self.err2.write(oprot)
            oprot.writeFieldEnd()
        if self.err3 is not None:
            oprot.writeFieldBegin("err3", TType.STRUCT, 3)
            self.err3.write(oprot)
            oprot.writeFieldEnd()
        if self.err4 is not None:
            oprot.writeFieldBegin("err4", TType.STRUCT, 4)
            self.err4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.err1)
        value = (value * 31) ^ hash(self.err2)
        value = (value * 31) ^ hash(self.err3)
        value = (value * 31) ^ hash(self.err4)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class isFrozen_args:
    """
  Attributes:
   - name
   - uri
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "name", None, None,),  # 1
        (2, TType.STRING, "uri", None, None,),  # 2
    )

    def __init__(
        self, name=None, uri=None,
    ):
        self.name = name
        self.uri = uri

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.uri = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("isFrozen_args")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        if self.uri is not None:
            oprot.writeFieldBegin("uri", TType.STRING, 2)
            oprot.writeString(self.uri)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocol.TProtocolException(message="Required field name is unset!")
        if self.uri is None:
            raise TProtocol.TProtocolException(message="Required field uri is unset!")
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.name)
        value = (value * 31) ^ hash(self.uri)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class isFrozen_result:
    """
  Attributes:
   - success
   - err1
   - err2
  """

    thrift_spec = (
        (0, TType.BOOL, "success", None, None,),  # 0
        (
            1,
            TType.STRUCT,
            "err1",
            (HawkInstanceNotFound, HawkInstanceNotFound.thrift_spec),
            None,
        ),  # 1
        (
            2,
            TType.STRUCT,
            "err2",
            (HawkInstanceNotRunning, HawkInstanceNotRunning.thrift_spec),
            None,
        ),  # 2
    )

    def __init__(
        self, success=None, err1=None, err2=None,
    ):
        self.success = success
        self.err1 = err1
        self.err2 = err2

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.err1 = HawkInstanceNotFound()
                    self.err1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.err2 = HawkInstanceNotRunning()
                    self.err2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("isFrozen_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.err1 is not None:
            oprot.writeFieldBegin("err1", TType.STRUCT, 1)
            self.err1.write(oprot)
            oprot.writeFieldEnd()
        if self.err2 is not None:
            oprot.writeFieldBegin("err2", TType.STRUCT, 2)
            self.err2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.success)
        value = (value * 31) ^ hash(self.err1)
        value = (value * 31) ^ hash(self.err2)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class setFrozen_args:
    """
  Attributes:
   - name
   - uri
   - isFrozen
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "name", None, None,),  # 1
        (2, TType.STRING, "uri", None, None,),  # 2
        (3, TType.BOOL, "isFrozen", None, None,),  # 3
    )

    def __init__(
        self, name=None, uri=None, isFrozen=None,
    ):
        self.name = name
        self.uri = uri
        self.isFrozen = isFrozen

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.uri = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.isFrozen = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("setFrozen_args")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        if self.uri is not None:
            oprot.writeFieldBegin("uri", TType.STRING, 2)
            oprot.writeString(self.uri)
            oprot.writeFieldEnd()
        if self.isFrozen is not None:
            oprot.writeFieldBegin("isFrozen", TType.BOOL, 3)
            oprot.writeBool(self.isFrozen)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocol.TProtocolException(message="Required field name is unset!")
        if self.uri is None:
            raise TProtocol.TProtocolException(message="Required field uri is unset!")
        if self.isFrozen is None:
            raise TProtocol.TProtocolException(
                message="Required field isFrozen is unset!"
            )
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.name)
        value = (value * 31) ^ hash(self.uri)
        value = (value * 31) ^ hash(self.isFrozen)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class setFrozen_result:
    """
  Attributes:
   - err1
   - err2
  """

    thrift_spec = (
        None,  # 0
        (
            1,
            TType.STRUCT,
            "err1",
            (HawkInstanceNotFound, HawkInstanceNotFound.thrift_spec),
            None,
        ),  # 1
        (
            2,
            TType.STRUCT,
            "err2",
            (HawkInstanceNotRunning, HawkInstanceNotRunning.thrift_spec),
            None,
        ),  # 2
    )

    def __init__(
        self, err1=None, err2=None,
    ):
        self.err1 = err1
        self.err2 = err2

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.err1 = HawkInstanceNotFound()
                    self.err1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.err2 = HawkInstanceNotRunning()
                    self.err2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("setFrozen_result")
        if self.err1 is not None:
            oprot.writeFieldBegin("err1", TType.STRUCT, 1)
            self.err1.write(oprot)
            oprot.writeFieldEnd()
        if self.err2 is not None:
            oprot.writeFieldBegin("err2", TType.STRUCT, 2)
            self.err2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.err1)
        value = (value * 31) ^ hash(self.err2)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class removeRepository_args:
    """
  Attributes:
   - name
   - uri
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "name", None, None,),  # 1
        (2, TType.STRING, "uri", None, None,),  # 2
    )

    def __init__(
        self, name=None, uri=None,
    ):
        self.name = name
        self.uri = uri

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.uri = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("removeRepository_args")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        if self.uri is not None:
            oprot.writeFieldBegin("uri", TType.STRING, 2)
            oprot.writeString(self.uri)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocol.TProtocolException(message="Required field name is unset!")
        if self.uri is None:
            raise TProtocol.TProtocolException(message="Required field uri is unset!")
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.name)
        value = (value * 31) ^ hash(self.uri)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class removeRepository_result:
    """
  Attributes:
   - err1
   - err2
  """

    thrift_spec = (
        None,  # 0
        (
            1,
            TType.STRUCT,
            "err1",
            (HawkInstanceNotFound, HawkInstanceNotFound.thrift_spec),
            None,
        ),  # 1
        (
            2,
            TType.STRUCT,
            "err2",
            (HawkInstanceNotRunning, HawkInstanceNotRunning.thrift_spec),
            None,
        ),  # 2
    )

    def __init__(
        self, err1=None, err2=None,
    ):
        self.err1 = err1
        self.err2 = err2

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.err1 = HawkInstanceNotFound()
                    self.err1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.err2 = HawkInstanceNotRunning()
                    self.err2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("removeRepository_result")
        if self.err1 is not None:
            oprot.writeFieldBegin("err1", TType.STRUCT, 1)
            self.err1.write(oprot)
            oprot.writeFieldEnd()
        if self.err2 is not None:
            oprot.writeFieldBegin("err2", TType.STRUCT, 2)
            self.err2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.err1)
        value = (value * 31) ^ hash(self.err2)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class updateRepositoryCredentials_args:
    """
  Attributes:
   - name
   - uri
   - cred
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "name", None, None,),  # 1
        (2, TType.STRING, "uri", None, None,),  # 2
        (3, TType.STRUCT, "cred", (Credentials, Credentials.thrift_spec), None,),  # 3
    )

    def __init__(
        self, name=None, uri=None, cred=None,
    ):
        self.name = name
        self.uri = uri
        self.cred = cred

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.uri = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.cred = Credentials()
                    self.cred.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("updateRepositoryCredentials_args")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        if self.uri is not None:
            oprot.writeFieldBegin("uri", TType.STRING, 2)
            oprot.writeString(self.uri)
            oprot.writeFieldEnd()
        if self.cred is not None:
            oprot.writeFieldBegin("cred", TType.STRUCT, 3)
            self.cred.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocol.TProtocolException(message="Required field name is unset!")
        if self.uri is None:
            raise TProtocol.TProtocolException(message="Required field uri is unset!")
        if self.cred is None:
            raise TProtocol.TProtocolException(message="Required field cred is unset!")
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.name)
        value = (value * 31) ^ hash(self.uri)
        value = (value * 31) ^ hash(self.cred)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class updateRepositoryCredentials_result:
    """
  Attributes:
   - err1
   - err2
  """

    thrift_spec = (
        None,  # 0
        (
            1,
            TType.STRUCT,
            "err1",
            (HawkInstanceNotFound, HawkInstanceNotFound.thrift_spec),
            None,
        ),  # 1
        (
            2,
            TType.STRUCT,
            "err2",
            (HawkInstanceNotRunning, HawkInstanceNotRunning.thrift_spec),
            None,
        ),  # 2
    )

    def __init__(
        self, err1=None, err2=None,
    ):
        self.err1 = err1
        self.err2 = err2

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.err1 = HawkInstanceNotFound()
                    self.err1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.err2 = HawkInstanceNotRunning()
                    self.err2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("updateRepositoryCredentials_result")
        if self.err1 is not None:
            oprot.writeFieldBegin("err1", TType.STRUCT, 1)
            self.err1.write(oprot)
            oprot.writeFieldEnd()
        if self.err2 is not None:
            oprot.writeFieldBegin("err2", TType.STRUCT, 2)
            self.err2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.err1)
        value = (value * 31) ^ hash(self.err2)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class listRepositories_args:
    """
  Attributes:
   - name
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "name", None, None,),  # 1
    )

    def __init__(
        self, name=None,
    ):
        self.name = name

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("listRepositories_args")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocol.TProtocolException(message="Required field name is unset!")
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.name)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class listRepositories_result:
    """
  Attributes:
   - success
   - err1
   - err2
  """

    thrift_spec = (
        (
            0,
            TType.LIST,
            "success",
            (TType.STRUCT, (Repository, Repository.thrift_spec)),
            None,
        ),  # 0
        (
            1,
            TType.STRUCT,
            "err1",
            (HawkInstanceNotFound, HawkInstanceNotFound.thrift_spec),
            None,
        ),  # 1
        (
            2,
            TType.STRUCT,
            "err2",
            (HawkInstanceNotRunning, HawkInstanceNotRunning.thrift_spec),
            None,
        ),  # 2
    )

    def __init__(
        self, success=None, err1=None, err2=None,
    ):
        self.success = success
        self.err1 = err1
        self.err2 = err2

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype300, _size297) = iprot.readListBegin()
                    for _i301 in range(_size297):
                        _elem302 = Repository()
                        _elem302.read(iprot)
                        self.success.append(_elem302)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.err1 = HawkInstanceNotFound()
                    self.err1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.err2 = HawkInstanceNotRunning()
                    self.err2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("listRepositories_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter303 in self.success:
                iter303.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.err1 is not None:
            oprot.writeFieldBegin("err1", TType.STRUCT, 1)
            self.err1.write(oprot)
            oprot.writeFieldEnd()
        if self.err2 is not None:
            oprot.writeFieldBegin("err2", TType.STRUCT, 2)
            self.err2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.success)
        value = (value * 31) ^ hash(self.err1)
        value = (value * 31) ^ hash(self.err2)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class listRepositoryTypes_args:

    thrift_spec = ()

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("listRepositoryTypes_args")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class listRepositoryTypes_result:
    """
  Attributes:
   - success
  """

    thrift_spec = ((0, TType.LIST, "success", (TType.STRING, None), None,),)  # 0

    def __init__(
        self, success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype307, _size304) = iprot.readListBegin()
                    for _i308 in range(_size304):
                        _elem309 = iprot.readString()
                        self.success.append(_elem309)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("listRepositoryTypes_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter310 in self.success:
                oprot.writeString(iter310)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.success)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class listFiles_args:
    """
  Attributes:
   - name
   - repository
   - filePatterns
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "name", None, None,),  # 1
        (2, TType.LIST, "repository", (TType.STRING, None), None,),  # 2
        (3, TType.LIST, "filePatterns", (TType.STRING, None), None,),  # 3
    )

    def __init__(
        self, name=None, repository=None, filePatterns=None,
    ):
        self.name = name
        self.repository = repository
        self.filePatterns = filePatterns

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.repository = []
                    (_etype314, _size311) = iprot.readListBegin()
                    for _i315 in range(_size311):
                        _elem316 = iprot.readString()
                        self.repository.append(_elem316)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.filePatterns = []
                    (_etype320, _size317) = iprot.readListBegin()
                    for _i321 in range(_size317):
                        _elem322 = iprot.readString()
                        self.filePatterns.append(_elem322)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("listFiles_args")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        if self.repository is not None:
            oprot.writeFieldBegin("repository", TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.repository))
            for iter323 in self.repository:
                oprot.writeString(iter323)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.filePatterns is not None:
            oprot.writeFieldBegin("filePatterns", TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.filePatterns))
            for iter324 in self.filePatterns:
                oprot.writeString(iter324)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocol.TProtocolException(message="Required field name is unset!")
        if self.repository is None:
            raise TProtocol.TProtocolException(
                message="Required field repository is unset!"
            )
        if self.filePatterns is None:
            raise TProtocol.TProtocolException(
                message="Required field filePatterns is unset!"
            )
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.name)
        value = (value * 31) ^ hash(self.repository)
        value = (value * 31) ^ hash(self.filePatterns)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class listFiles_result:
    """
  Attributes:
   - success
   - err1
   - err2
  """

    thrift_spec = (
        (0, TType.LIST, "success", (TType.STRING, None), None,),  # 0
        (
            1,
            TType.STRUCT,
            "err1",
            (HawkInstanceNotFound, HawkInstanceNotFound.thrift_spec),
            None,
        ),  # 1
        (
            2,
            TType.STRUCT,
            "err2",
            (HawkInstanceNotRunning, HawkInstanceNotRunning.thrift_spec),
            None,
        ),  # 2
    )

    def __init__(
        self, success=None, err1=None, err2=None,
    ):
        self.success = success
        self.err1 = err1
        self.err2 = err2

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype328, _size325) = iprot.readListBegin()
                    for _i329 in range(_size325):
                        _elem330 = iprot.readString()
                        self.success.append(_elem330)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.err1 = HawkInstanceNotFound()
                    self.err1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.err2 = HawkInstanceNotRunning()
                    self.err2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("listFiles_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter331 in self.success:
                oprot.writeString(iter331)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.err1 is not None:
            oprot.writeFieldBegin("err1", TType.STRUCT, 1)
            self.err1.write(oprot)
            oprot.writeFieldEnd()
        if self.err2 is not None:
            oprot.writeFieldBegin("err2", TType.STRUCT, 2)
            self.err2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.success)
        value = (value * 31) ^ hash(self.err1)
        value = (value * 31) ^ hash(self.err2)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class configurePolling_args:
    """
  Attributes:
   - name
   - base
   - max
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "name", None, None,),  # 1
        (2, TType.I32, "base", None, None,),  # 2
        (3, TType.I32, "max", None, None,),  # 3
    )

    def __init__(
        self, name=None, base=None, max=None,
    ):
        self.name = name
        self.base = base
        self.max = max

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.base = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.max = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("configurePolling_args")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        if self.base is not None:
            oprot.writeFieldBegin("base", TType.I32, 2)
            oprot.writeI32(self.base)
            oprot.writeFieldEnd()
        if self.max is not None:
            oprot.writeFieldBegin("max", TType.I32, 3)
            oprot.writeI32(self.max)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocol.TProtocolException(message="Required field name is unset!")
        if self.base is None:
            raise TProtocol.TProtocolException(message="Required field base is unset!")
        if self.max is None:
            raise TProtocol.TProtocolException(message="Required field max is unset!")
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.name)
        value = (value * 31) ^ hash(self.base)
        value = (value * 31) ^ hash(self.max)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class configurePolling_result:
    """
  Attributes:
   - err1
   - err2
   - err3
  """

    thrift_spec = (
        None,  # 0
        (
            1,
            TType.STRUCT,
            "err1",
            (HawkInstanceNotFound, HawkInstanceNotFound.thrift_spec),
            None,
        ),  # 1
        (
            2,
            TType.STRUCT,
            "err2",
            (HawkInstanceNotRunning, HawkInstanceNotRunning.thrift_spec),
            None,
        ),  # 2
        (
            3,
            TType.STRUCT,
            "err3",
            (InvalidPollingConfiguration, InvalidPollingConfiguration.thrift_spec),
            None,
        ),  # 3
    )

    def __init__(
        self, err1=None, err2=None, err3=None,
    ):
        self.err1 = err1
        self.err2 = err2
        self.err3 = err3

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.err1 = HawkInstanceNotFound()
                    self.err1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.err2 = HawkInstanceNotRunning()
                    self.err2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.err3 = InvalidPollingConfiguration()
                    self.err3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("configurePolling_result")
        if self.err1 is not None:
            oprot.writeFieldBegin("err1", TType.STRUCT, 1)
            self.err1.write(oprot)
            oprot.writeFieldEnd()
        if self.err2 is not None:
            oprot.writeFieldBegin("err2", TType.STRUCT, 2)
            self.err2.write(oprot)
            oprot.writeFieldEnd()
        if self.err3 is not None:
            oprot.writeFieldBegin("err3", TType.STRUCT, 3)
            self.err3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.err1)
        value = (value * 31) ^ hash(self.err2)
        value = (value * 31) ^ hash(self.err3)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class addDerivedAttribute_args:
    """
  Attributes:
   - name
   - spec
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "name", None, None,),  # 1
        (
            2,
            TType.STRUCT,
            "spec",
            (DerivedAttributeSpec, DerivedAttributeSpec.thrift_spec),
            None,
        ),  # 2
    )

    def __init__(
        self, name=None, spec=None,
    ):
        self.name = name
        self.spec = spec

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.spec = DerivedAttributeSpec()
                    self.spec.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("addDerivedAttribute_args")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        if self.spec is not None:
            oprot.writeFieldBegin("spec", TType.STRUCT, 2)
            self.spec.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocol.TProtocolException(message="Required field name is unset!")
        if self.spec is None:
            raise TProtocol.TProtocolException(message="Required field spec is unset!")
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.name)
        value = (value * 31) ^ hash(self.spec)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class addDerivedAttribute_result:
    """
  Attributes:
   - err1
   - err2
   - err3
  """

    thrift_spec = (
        None,  # 0
        (
            1,
            TType.STRUCT,
            "err1",
            (HawkInstanceNotFound, HawkInstanceNotFound.thrift_spec),
            None,
        ),  # 1
        (
            2,
            TType.STRUCT,
            "err2",
            (HawkInstanceNotRunning, HawkInstanceNotRunning.thrift_spec),
            None,
        ),  # 2
        (
            3,
            TType.STRUCT,
            "err3",
            (InvalidDerivedAttributeSpec, InvalidDerivedAttributeSpec.thrift_spec),
            None,
        ),  # 3
    )

    def __init__(
        self, err1=None, err2=None, err3=None,
    ):
        self.err1 = err1
        self.err2 = err2
        self.err3 = err3

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.err1 = HawkInstanceNotFound()
                    self.err1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.err2 = HawkInstanceNotRunning()
                    self.err2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.err3 = InvalidDerivedAttributeSpec()
                    self.err3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("addDerivedAttribute_result")
        if self.err1 is not None:
            oprot.writeFieldBegin("err1", TType.STRUCT, 1)
            self.err1.write(oprot)
            oprot.writeFieldEnd()
        if self.err2 is not None:
            oprot.writeFieldBegin("err2", TType.STRUCT, 2)
            self.err2.write(oprot)
            oprot.writeFieldEnd()
        if self.err3 is not None:
            oprot.writeFieldBegin("err3", TType.STRUCT, 3)
            self.err3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.err1)
        value = (value * 31) ^ hash(self.err2)
        value = (value * 31) ^ hash(self.err3)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class removeDerivedAttribute_args:
    """
  Attributes:
   - name
   - spec
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "name", None, None,),  # 1
        (
            2,
            TType.STRUCT,
            "spec",
            (DerivedAttributeSpec, DerivedAttributeSpec.thrift_spec),
            None,
        ),  # 2
    )

    def __init__(
        self, name=None, spec=None,
    ):
        self.name = name
        self.spec = spec

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.spec = DerivedAttributeSpec()
                    self.spec.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("removeDerivedAttribute_args")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        if self.spec is not None:
            oprot.writeFieldBegin("spec", TType.STRUCT, 2)
            self.spec.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocol.TProtocolException(message="Required field name is unset!")
        if self.spec is None:
            raise TProtocol.TProtocolException(message="Required field spec is unset!")
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.name)
        value = (value * 31) ^ hash(self.spec)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class removeDerivedAttribute_result:
    """
  Attributes:
   - err1
   - err2
  """

    thrift_spec = (
        None,  # 0
        (
            1,
            TType.STRUCT,
            "err1",
            (HawkInstanceNotFound, HawkInstanceNotFound.thrift_spec),
            None,
        ),  # 1
        (
            2,
            TType.STRUCT,
            "err2",
            (HawkInstanceNotRunning, HawkInstanceNotRunning.thrift_spec),
            None,
        ),  # 2
    )

    def __init__(
        self, err1=None, err2=None,
    ):
        self.err1 = err1
        self.err2 = err2

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.err1 = HawkInstanceNotFound()
                    self.err1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.err2 = HawkInstanceNotRunning()
                    self.err2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("removeDerivedAttribute_result")
        if self.err1 is not None:
            oprot.writeFieldBegin("err1", TType.STRUCT, 1)
            self.err1.write(oprot)
            oprot.writeFieldEnd()
        if self.err2 is not None:
            oprot.writeFieldBegin("err2", TType.STRUCT, 2)
            self.err2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.err1)
        value = (value * 31) ^ hash(self.err2)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class listDerivedAttributes_args:
    """
  Attributes:
   - name
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "name", None, None,),  # 1
    )

    def __init__(
        self, name=None,
    ):
        self.name = name

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("listDerivedAttributes_args")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocol.TProtocolException(message="Required field name is unset!")
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.name)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class listDerivedAttributes_result:
    """
  Attributes:
   - success
   - err1
   - err2
  """

    thrift_spec = (
        (
            0,
            TType.LIST,
            "success",
            (TType.STRUCT, (DerivedAttributeSpec, DerivedAttributeSpec.thrift_spec)),
            None,
        ),  # 0
        (
            1,
            TType.STRUCT,
            "err1",
            (HawkInstanceNotFound, HawkInstanceNotFound.thrift_spec),
            None,
        ),  # 1
        (
            2,
            TType.STRUCT,
            "err2",
            (HawkInstanceNotRunning, HawkInstanceNotRunning.thrift_spec),
            None,
        ),  # 2
    )

    def __init__(
        self, success=None, err1=None, err2=None,
    ):
        self.success = success
        self.err1 = err1
        self.err2 = err2

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype335, _size332) = iprot.readListBegin()
                    for _i336 in range(_size332):
                        _elem337 = DerivedAttributeSpec()
                        _elem337.read(iprot)
                        self.success.append(_elem337)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.err1 = HawkInstanceNotFound()
                    self.err1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.err2 = HawkInstanceNotRunning()
                    self.err2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("listDerivedAttributes_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter338 in self.success:
                iter338.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.err1 is not None:
            oprot.writeFieldBegin("err1", TType.STRUCT, 1)
            self.err1.write(oprot)
            oprot.writeFieldEnd()
        if self.err2 is not None:
            oprot.writeFieldBegin("err2", TType.STRUCT, 2)
            self.err2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.success)
        value = (value * 31) ^ hash(self.err1)
        value = (value * 31) ^ hash(self.err2)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class addIndexedAttribute_args:
    """
  Attributes:
   - name
   - spec
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "name", None, None,),  # 1
        (
            2,
            TType.STRUCT,
            "spec",
            (IndexedAttributeSpec, IndexedAttributeSpec.thrift_spec),
            None,
        ),  # 2
    )

    def __init__(
        self, name=None, spec=None,
    ):
        self.name = name
        self.spec = spec

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.spec = IndexedAttributeSpec()
                    self.spec.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("addIndexedAttribute_args")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        if self.spec is not None:
            oprot.writeFieldBegin("spec", TType.STRUCT, 2)
            self.spec.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocol.TProtocolException(message="Required field name is unset!")
        if self.spec is None:
            raise TProtocol.TProtocolException(message="Required field spec is unset!")
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.name)
        value = (value * 31) ^ hash(self.spec)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class addIndexedAttribute_result:
    """
  Attributes:
   - err1
   - err2
   - err3
  """

    thrift_spec = (
        None,  # 0
        (
            1,
            TType.STRUCT,
            "err1",
            (HawkInstanceNotFound, HawkInstanceNotFound.thrift_spec),
            None,
        ),  # 1
        (
            2,
            TType.STRUCT,
            "err2",
            (HawkInstanceNotRunning, HawkInstanceNotRunning.thrift_spec),
            None,
        ),  # 2
        (
            3,
            TType.STRUCT,
            "err3",
            (InvalidIndexedAttributeSpec, InvalidIndexedAttributeSpec.thrift_spec),
            None,
        ),  # 3
    )

    def __init__(
        self, err1=None, err2=None, err3=None,
    ):
        self.err1 = err1
        self.err2 = err2
        self.err3 = err3

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.err1 = HawkInstanceNotFound()
                    self.err1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.err2 = HawkInstanceNotRunning()
                    self.err2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.err3 = InvalidIndexedAttributeSpec()
                    self.err3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("addIndexedAttribute_result")
        if self.err1 is not None:
            oprot.writeFieldBegin("err1", TType.STRUCT, 1)
            self.err1.write(oprot)
            oprot.writeFieldEnd()
        if self.err2 is not None:
            oprot.writeFieldBegin("err2", TType.STRUCT, 2)
            self.err2.write(oprot)
            oprot.writeFieldEnd()
        if self.err3 is not None:
            oprot.writeFieldBegin("err3", TType.STRUCT, 3)
            self.err3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.err1)
        value = (value * 31) ^ hash(self.err2)
        value = (value * 31) ^ hash(self.err3)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class removeIndexedAttribute_args:
    """
  Attributes:
   - name
   - spec
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "name", None, None,),  # 1
        (
            2,
            TType.STRUCT,
            "spec",
            (IndexedAttributeSpec, IndexedAttributeSpec.thrift_spec),
            None,
        ),  # 2
    )

    def __init__(
        self, name=None, spec=None,
    ):
        self.name = name
        self.spec = spec

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.spec = IndexedAttributeSpec()
                    self.spec.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("removeIndexedAttribute_args")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        if self.spec is not None:
            oprot.writeFieldBegin("spec", TType.STRUCT, 2)
            self.spec.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocol.TProtocolException(message="Required field name is unset!")
        if self.spec is None:
            raise TProtocol.TProtocolException(message="Required field spec is unset!")
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.name)
        value = (value * 31) ^ hash(self.spec)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class removeIndexedAttribute_result:
    """
  Attributes:
   - err1
   - err2
  """

    thrift_spec = (
        None,  # 0
        (
            1,
            TType.STRUCT,
            "err1",
            (HawkInstanceNotFound, HawkInstanceNotFound.thrift_spec),
            None,
        ),  # 1
        (
            2,
            TType.STRUCT,
            "err2",
            (HawkInstanceNotRunning, HawkInstanceNotRunning.thrift_spec),
            None,
        ),  # 2
    )

    def __init__(
        self, err1=None, err2=None,
    ):
        self.err1 = err1
        self.err2 = err2

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.err1 = HawkInstanceNotFound()
                    self.err1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.err2 = HawkInstanceNotRunning()
                    self.err2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("removeIndexedAttribute_result")
        if self.err1 is not None:
            oprot.writeFieldBegin("err1", TType.STRUCT, 1)
            self.err1.write(oprot)
            oprot.writeFieldEnd()
        if self.err2 is not None:
            oprot.writeFieldBegin("err2", TType.STRUCT, 2)
            self.err2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.err1)
        value = (value * 31) ^ hash(self.err2)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class listIndexedAttributes_args:
    """
  Attributes:
   - name
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "name", None, None,),  # 1
    )

    def __init__(
        self, name=None,
    ):
        self.name = name

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("listIndexedAttributes_args")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocol.TProtocolException(message="Required field name is unset!")
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.name)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class listIndexedAttributes_result:
    """
  Attributes:
   - success
   - err1
   - err2
  """

    thrift_spec = (
        (
            0,
            TType.LIST,
            "success",
            (TType.STRUCT, (IndexedAttributeSpec, IndexedAttributeSpec.thrift_spec)),
            None,
        ),  # 0
        (
            1,
            TType.STRUCT,
            "err1",
            (HawkInstanceNotFound, HawkInstanceNotFound.thrift_spec),
            None,
        ),  # 1
        (
            2,
            TType.STRUCT,
            "err2",
            (HawkInstanceNotRunning, HawkInstanceNotRunning.thrift_spec),
            None,
        ),  # 2
    )

    def __init__(
        self, success=None, err1=None, err2=None,
    ):
        self.success = success
        self.err1 = err1
        self.err2 = err2

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype342, _size339) = iprot.readListBegin()
                    for _i343 in range(_size339):
                        _elem344 = IndexedAttributeSpec()
                        _elem344.read(iprot)
                        self.success.append(_elem344)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.err1 = HawkInstanceNotFound()
                    self.err1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.err2 = HawkInstanceNotRunning()
                    self.err2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("listIndexedAttributes_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter345 in self.success:
                iter345.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.err1 is not None:
            oprot.writeFieldBegin("err1", TType.STRUCT, 1)
            self.err1.write(oprot)
            oprot.writeFieldEnd()
        if self.err2 is not None:
            oprot.writeFieldBegin("err2", TType.STRUCT, 2)
            self.err2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.success)
        value = (value * 31) ^ hash(self.err1)
        value = (value * 31) ^ hash(self.err2)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getModel_args:
    """
  Attributes:
   - name
   - options
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "name", None, None,),  # 1
        (
            2,
            TType.STRUCT,
            "options",
            (HawkQueryOptions, HawkQueryOptions.thrift_spec),
            None,
        ),  # 2
    )

    def __init__(
        self, name=None, options=None,
    ):
        self.name = name
        self.options = options

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.options = HawkQueryOptions()
                    self.options.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("getModel_args")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        if self.options is not None:
            oprot.writeFieldBegin("options", TType.STRUCT, 2)
            self.options.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocol.TProtocolException(message="Required field name is unset!")
        if self.options is None:
            raise TProtocol.TProtocolException(
                message="Required field options is unset!"
            )
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.name)
        value = (value * 31) ^ hash(self.options)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getModel_result:
    """
  Attributes:
   - success
   - err1
   - err2
  """

    thrift_spec = (
        (
            0,
            TType.LIST,
            "success",
            (TType.STRUCT, (ModelElement, ModelElement.thrift_spec)),
            None,
        ),  # 0
        (
            1,
            TType.STRUCT,
            "err1",
            (HawkInstanceNotFound, HawkInstanceNotFound.thrift_spec),
            None,
        ),  # 1
        (
            2,
            TType.STRUCT,
            "err2",
            (HawkInstanceNotRunning, HawkInstanceNotRunning.thrift_spec),
            None,
        ),  # 2
    )

    def __init__(
        self, success=None, err1=None, err2=None,
    ):
        self.success = success
        self.err1 = err1
        self.err2 = err2

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype349, _size346) = iprot.readListBegin()
                    for _i350 in range(_size346):
                        _elem351 = ModelElement()
                        _elem351.read(iprot)
                        self.success.append(_elem351)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.err1 = HawkInstanceNotFound()
                    self.err1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.err2 = HawkInstanceNotRunning()
                    self.err2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("getModel_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter352 in self.success:
                iter352.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.err1 is not None:
            oprot.writeFieldBegin("err1", TType.STRUCT, 1)
            self.err1.write(oprot)
            oprot.writeFieldEnd()
        if self.err2 is not None:
            oprot.writeFieldBegin("err2", TType.STRUCT, 2)
            self.err2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.success)
        value = (value * 31) ^ hash(self.err1)
        value = (value * 31) ^ hash(self.err2)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getRootElements_args:
    """
  Attributes:
   - name
   - options
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "name", None, None,),  # 1
        (
            2,
            TType.STRUCT,
            "options",
            (HawkQueryOptions, HawkQueryOptions.thrift_spec),
            None,
        ),  # 2
    )

    def __init__(
        self, name=None, options=None,
    ):
        self.name = name
        self.options = options

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.options = HawkQueryOptions()
                    self.options.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("getRootElements_args")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        if self.options is not None:
            oprot.writeFieldBegin("options", TType.STRUCT, 2)
            self.options.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocol.TProtocolException(message="Required field name is unset!")
        if self.options is None:
            raise TProtocol.TProtocolException(
                message="Required field options is unset!"
            )
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.name)
        value = (value * 31) ^ hash(self.options)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getRootElements_result:
    """
  Attributes:
   - success
  """

    thrift_spec = (
        (
            0,
            TType.LIST,
            "success",
            (TType.STRUCT, (ModelElement, ModelElement.thrift_spec)),
            None,
        ),  # 0
    )

    def __init__(
        self, success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype356, _size353) = iprot.readListBegin()
                    for _i357 in range(_size353):
                        _elem358 = ModelElement()
                        _elem358.read(iprot)
                        self.success.append(_elem358)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("getRootElements_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter359 in self.success:
                iter359.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.success)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class watchStateChanges_args:
    """
  Attributes:
   - name
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "name", None, None,),  # 1
    )

    def __init__(
        self, name=None,
    ):
        self.name = name

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("watchStateChanges_args")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocol.TProtocolException(message="Required field name is unset!")
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.name)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class watchStateChanges_result:
    """
  Attributes:
   - success
   - err1
   - err2
  """

    thrift_spec = (
        (
            0,
            TType.STRUCT,
            "success",
            (Subscription, Subscription.thrift_spec),
            None,
        ),  # 0
        (
            1,
            TType.STRUCT,
            "err1",
            (HawkInstanceNotFound, HawkInstanceNotFound.thrift_spec),
            None,
        ),  # 1
        (
            2,
            TType.STRUCT,
            "err2",
            (HawkInstanceNotRunning, HawkInstanceNotRunning.thrift_spec),
            None,
        ),  # 2
    )

    def __init__(
        self, success=None, err1=None, err2=None,
    ):
        self.success = success
        self.err1 = err1
        self.err2 = err2

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Subscription()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.err1 = HawkInstanceNotFound()
                    self.err1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.err2 = HawkInstanceNotRunning()
                    self.err2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("watchStateChanges_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.err1 is not None:
            oprot.writeFieldBegin("err1", TType.STRUCT, 1)
            self.err1.write(oprot)
            oprot.writeFieldEnd()
        if self.err2 is not None:
            oprot.writeFieldBegin("err2", TType.STRUCT, 2)
            self.err2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.success)
        value = (value * 31) ^ hash(self.err1)
        value = (value * 31) ^ hash(self.err2)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class watchModelChanges_args:
    """
  Attributes:
   - name
   - repositoryUri
   - filePath
   - clientID
   - durableEvents
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "name", None, None,),  # 1
        (2, TType.STRING, "repositoryUri", None, None,),  # 2
        (3, TType.LIST, "filePath", (TType.STRING, None), None,),  # 3
        (4, TType.STRING, "clientID", None, None,),  # 4
        (5, TType.I32, "durableEvents", None, None,),  # 5
    )

    def __init__(
        self,
        name=None,
        repositoryUri=None,
        filePath=None,
        clientID=None,
        durableEvents=None,
    ):
        self.name = name
        self.repositoryUri = repositoryUri
        self.filePath = filePath
        self.clientID = clientID
        self.durableEvents = durableEvents

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.repositoryUri = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.filePath = []
                    (_etype363, _size360) = iprot.readListBegin()
                    for _i364 in range(_size360):
                        _elem365 = iprot.readString()
                        self.filePath.append(_elem365)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.clientID = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.durableEvents = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("watchModelChanges_args")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        if self.repositoryUri is not None:
            oprot.writeFieldBegin("repositoryUri", TType.STRING, 2)
            oprot.writeString(self.repositoryUri)
            oprot.writeFieldEnd()
        if self.filePath is not None:
            oprot.writeFieldBegin("filePath", TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.filePath))
            for iter366 in self.filePath:
                oprot.writeString(iter366)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.clientID is not None:
            oprot.writeFieldBegin("clientID", TType.STRING, 4)
            oprot.writeString(self.clientID)
            oprot.writeFieldEnd()
        if self.durableEvents is not None:
            oprot.writeFieldBegin("durableEvents", TType.I32, 5)
            oprot.writeI32(self.durableEvents)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocol.TProtocolException(message="Required field name is unset!")
        if self.repositoryUri is None:
            raise TProtocol.TProtocolException(
                message="Required field repositoryUri is unset!"
            )
        if self.filePath is None:
            raise TProtocol.TProtocolException(
                message="Required field filePath is unset!"
            )
        if self.clientID is None:
            raise TProtocol.TProtocolException(
                message="Required field clientID is unset!"
            )
        if self.durableEvents is None:
            raise TProtocol.TProtocolException(
                message="Required field durableEvents is unset!"
            )
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.name)
        value = (value * 31) ^ hash(self.repositoryUri)
        value = (value * 31) ^ hash(self.filePath)
        value = (value * 31) ^ hash(self.clientID)
        value = (value * 31) ^ hash(self.durableEvents)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class watchModelChanges_result:
    """
  Attributes:
   - success
   - err1
   - err2
  """

    thrift_spec = (
        (
            0,
            TType.STRUCT,
            "success",
            (Subscription, Subscription.thrift_spec),
            None,
        ),  # 0
        (
            1,
            TType.STRUCT,
            "err1",
            (HawkInstanceNotFound, HawkInstanceNotFound.thrift_spec),
            None,
        ),  # 1
        (
            2,
            TType.STRUCT,
            "err2",
            (HawkInstanceNotRunning, HawkInstanceNotRunning.thrift_spec),
            None,
        ),  # 2
    )

    def __init__(
        self, success=None, err1=None, err2=None,
    ):
        self.success = success
        self.err1 = err1
        self.err2 = err2

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Subscription()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.err1 = HawkInstanceNotFound()
                    self.err1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.err2 = HawkInstanceNotRunning()
                    self.err2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("watchModelChanges_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.err1 is not None:
            oprot.writeFieldBegin("err1", TType.STRUCT, 1)
            self.err1.write(oprot)
            oprot.writeFieldEnd()
        if self.err2 is not None:
            oprot.writeFieldBegin("err2", TType.STRUCT, 2)
            self.err2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.success)
        value = (value * 31) ^ hash(self.err1)
        value = (value * 31) ^ hash(self.err2)
        return value

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
